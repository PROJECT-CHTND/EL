<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EL - Eager Learner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Sans+JP:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['IBM Plex Sans', 'IBM Plex Sans JP', 'system-ui', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        surface: {
                            0: '#0f1114',
                            1: '#16181d',
                            2: '#1e2128',
                            3: '#262a33',
                            4: '#2e333e',
                        },
                        accent: {
                            DEFAULT: '#e5a84b',
                            dim: '#b8863c',
                            bright: '#f5c46b',
                        },
                        verified: '#4ade80',
                        conflict: '#f87171',
                        pending: '#94a3b8',
                    }
                }
            }
        }
    </script>
    <style>
        * {
            font-family: 'IBM Plex Sans', 'IBM Plex Sans JP', system-ui, sans-serif;
        }
        
        /* Subtle entry animation */
        .fade-up {
            animation: fadeUp 0.2s ease-out;
        }
        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Minimal typing indicator */
        .typing-dot {
            animation: typingDot 1.2s infinite;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.15s; }
        .typing-dot:nth-child(3) { animation-delay: 0.3s; }
        @keyframes typingDot {
            0%, 60%, 100% { opacity: 0.3; }
            30% { opacity: 1; }
        }
        
        /* Custom scrollbar - minimal */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.15); }
        
        /* Focus states */
        input:focus, textarea:focus, button:focus-visible {
            outline: 2px solid rgba(229, 168, 75, 0.5);
            outline-offset: 1px;
        }
        
        /* Textarea */
        .msg-input {
            resize: none;
            min-height: 44px;
            max-height: 160px;
        }
        
        /* Markdown in messages */
        .prose-msg p { margin-bottom: 0.5rem; }
        .prose-msg p:last-child { margin-bottom: 0; }
        .prose-msg ul, .prose-msg ol { margin: 0.5rem 0 0.5rem 1.25rem; }
        .prose-msg ul { list-style: disc; }
        .prose-msg ol { list-style: decimal; }
        .prose-msg li { margin-bottom: 0.125rem; }
        .prose-msg strong { font-weight: 600; color: #f1f5f9; }
        .prose-msg code {
            background: rgba(255,255,255,0.06);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875em;
        }
        .prose-msg pre {
            background: rgba(0,0,0,0.3);
            padding: 0.75rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5rem 0;
        }
        .prose-msg pre code { background: transparent; padding: 0; }
        
        /* Knowledge Map container */
        #knowledge-map-canvas {
            width: 100%;
            height: 200px;
            position: relative;
        }
        #knowledge-map-canvas canvas,
        #km-modal-canvas canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Knowledge Map Modal */
        #knowledge-map-modal {
            opacity: 0;
            transition: opacity 0.25s ease;
        }
        #knowledge-map-modal.visible {
            opacity: 1;
        }
        #knowledge-map-modal #km-modal-content {
            transform: scale(0.92);
            transition: transform 0.25s ease;
        }
        #knowledge-map-modal.visible #km-modal-content {
            transform: scale(1);
        }
        
        /* Topic chip */
        .topic-chip {
            transition: background 0.15s, border-color 0.15s;
        }
        .topic-chip.covered { border-color: #4ade80; }
        .topic-chip.needs-verify { border-color: #e5a84b; }
        .topic-chip.missing { border-color: #94a3b8; }
        
        /* Fact row */
        .fact-row {
            transition: background 0.1s;
        }
        .fact-row:hover {
            background: rgba(255,255,255,0.03);
        }
        
        /* Status badge pulse for events */
        .pulse-once {
            animation: pulseOnce 0.3s ease-out;
        }
        @keyframes pulseOnce {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Session status indicators */
        .status-draft { color: #94a3b8; }
        .status-verified { color: #4ade80; }
        .status-conflict { color: #f87171; }
        
        /* Tag chip styles */
        .tag-chip {
            backdrop-filter: blur(8px);
            transition: all 0.15s ease;
        }
        .tag-chip:hover {
            filter: brightness(1.2);
        }
        
        /* Line clamp utility */
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Resize handles */
        .resize-handle {
            position: relative;
            width: 4px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.15s;
            z-index: 10;
            flex-shrink: 0;
        }
        .resize-handle::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: -2px;
            right: -2px;
        }
        .resize-handle:hover,
        .resize-handle.dragging {
            background: rgba(229, 168, 75, 0.4);
        }

        /* Left pane toggle button */
        .sidebar-toggle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e2128;
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            z-index: 20;
            transition: background 0.15s, left 0.2s;
            color: #94a3b8;
            font-size: 10px;
        }
        .sidebar-toggle:hover {
            background: #262a33;
            color: #e2e8f0;
        }

        /* Left pane transition */
        #left-pane {
            transition: width 0.2s ease, min-width 0.2s ease;
        }

        /* Collapsed left pane */
        #left-pane.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            overflow: hidden;
            padding: 0;
            border: none;
        }
        #left-pane.collapsed > * {
            opacity: 0;
            pointer-events: none;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            #left-pane:not(.collapsed) { width: 240px; min-width: 180px; }
        }
        @media (max-width: 768px) {
            #right-pane { display: none; }
            #resize-handle-right { display: none; }
        }
    </style>
</head>
<body class="bg-surface-0 text-slate-300 min-h-screen">
    <!-- Toast Container -->
    <div id="toast-container" class="fixed top-4 right-4 z-50 space-y-2 pointer-events-none"></div>

    <!-- Session Loading Overlay -->
    <div id="session-loading-overlay" class="fixed inset-0 z-40 bg-surface-0/80 backdrop-blur-sm flex items-center justify-center hidden transition-opacity duration-300 opacity-0">
        <div class="flex flex-col items-center gap-3 p-6 rounded-2xl bg-surface-1 border border-white/10 shadow-2xl">
            <svg class="animate-spin h-8 w-8 text-accent" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span id="session-loading-text" class="text-sm text-slate-300">„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÊ∫ñÂÇô‰∏≠...</span>
        </div>
    </div>

    <div class="h-screen flex flex-col">
        <!-- Header - minimal -->
        <header class="flex-none h-12 px-4 flex items-center justify-between border-b border-white/5">
            <div class="flex items-center gap-3">
                <button id="toggle-left-pane" class="p-1.5 rounded hover:bg-surface-2 transition-colors text-slate-400 hover:text-white" title="„Çµ„Ç§„Éâ„Éê„Éº„ÅÆË°®Á§∫ÂàáÊõø">
                    <svg id="toggle-left-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="1" y="2" width="14" height="12" rx="2" />
                        <line x1="5.5" y1="2" x2="5.5" y2="14" />
                    </svg>
                </button>
                <h1 class="text-sm font-semibold text-white tracking-tight">
                    EL<span class="text-slate-500 font-normal ml-1.5">Eager Learner</span>
                </h1>
            </div>
            <div class="flex items-center gap-2 text-xs text-slate-500">
                <span id="header-status">ÂæÖÊ©ü‰∏≠</span>
            </div>
        </header>

        <!-- Main 3-pane layout -->
        <div id="app-grid" class="flex-1 flex min-h-0">
            
            <!-- ===== LEFT PANE: Sessions Archive ===== -->
            <aside id="left-pane" class="border-r border-white/5 flex flex-col min-h-0" style="width: 260px; min-width: 180px; max-width: 480px; flex-shrink: 0;">
                <div class="flex-none p-3 border-b border-white/5">
                    <button 
                        id="new-session-btn"
                        data-session-btn
                        class="w-full py-2 px-3 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition-colors flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <span id="new-session-btn-text">+ Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥</span>
                        <span id="new-session-btn-spinner" class="hidden">
                            <svg class="animate-spin h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        </span>
                    </button>
                </div>
                <div class="flex-1 overflow-y-auto p-3">
                    <div class="text-xs text-slate-500 uppercase tracking-wider mb-2">Sessions</div>
                    <div id="session-list" class="space-y-1">
                        <p class="text-xs text-slate-600 py-4 text-center">Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                    </div>
                </div>
            </aside>

            <!-- Resize handle: left -->
            <div id="resize-handle-left" class="resize-handle"></div>

            <!-- ===== CENTER PANE: Interview ===== -->
            <main id="center-pane" class="flex-1 flex flex-col min-h-0 bg-surface-1">
                
                <!-- Start Screen -->
                <div id="start-screen" class="flex-1 flex items-center justify-center p-6">
                    <div class="w-full max-w-md">
                        <!-- Pending document review banner -->
                        <div id="pending-review-banner" class="hidden mb-6 p-4 bg-accent/5 border border-accent/15 rounded-xl">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="text-base">üìã</span>
                                <span class="text-sm text-white font-medium">„É¨„Éì„É•„ÉºÂæÖ„Å°„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà</span>
                            </div>
                            <p class="text-[11px] text-slate-500 mb-3">ÂàÜÊûê„ÅåÂÆå‰∫Ü„Åó„Åü„Éâ„Ç≠„É•„É°„É≥„Éà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶‰∫ãÂÆü„ÅÆÊ≠£Á¢∫ÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
                            <div id="pending-review-list" class="space-y-1.5"></div>
                        </div>

                        <div class="text-center mb-8">
                            <h2 class="text-xl font-semibold text-white mb-2">Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥</h2>
                            <p class="text-sm text-slate-500">Ë©±„Åó„Åü„ÅÑ„Åì„Å®„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                        </div>
                        <form id="start-form" class="space-y-4">
                            <div>
                                <label for="intent-input" class="block text-xs text-slate-400 mb-1.5">IntentÔºàÁõÆÁöÑÔºâ</label>
                                <input 
                                    type="text" 
                                    id="intent-input"
                                    placeholder="‰æã: ‰ªäÊó•„ÅÆÊ•≠Âãô„ÇíÊï¥ÁêÜ„Åó„Å¶Âæå„ÅßÊ§úÁ¥¢„Åß„Åç„ÇãÂΩ¢„Å´„Åó„Åü„ÅÑ"
                                    class="w-full px-4 py-3 bg-surface-2 border border-white/10 rounded-lg text-white placeholder-slate-500 text-sm"
                                    required
                                >
                            </div>
                            <button 
                                type="submit"
                                id="start-btn"
                                data-session-btn
                                class="w-full py-3 bg-accent hover:bg-accent-bright text-surface-0 font-medium rounded-lg transition-colors text-sm disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                            >
                                <span id="start-btn-text">ÈñãÂßã</span>
                                <span id="start-btn-spinner" class="hidden">
                                    <svg class="animate-spin h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                </span>
                            </button>
                        </form>
                    </div>
                </div>

                <!-- Chat Screen -->
                <div id="chat-screen" class="hidden flex flex-col flex-1 min-h-0">
                    
                    <!-- Messages -->
                    <div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-3">
                    </div>

                    <!-- Input -->
                    <div class="flex-none p-4 border-t border-white/5">
                        <form id="chat-form" class="flex gap-2">
                            <textarea 
                                id="message-input"
                                placeholder="„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÖ•Âäõ..."
                                rows="1"
                                class="msg-input flex-1 px-4 py-2.5 bg-surface-2 border border-white/10 rounded-lg text-white placeholder-slate-500 text-sm"
                            ></textarea>
                            <button 
                                type="submit"
                                id="send-btn"
                                class="px-4 py-2.5 bg-accent hover:bg-accent-bright disabled:bg-surface-3 disabled:text-slate-600 text-surface-0 font-medium rounded-lg transition-colors text-sm"
                            >
                                ÈÄÅ‰ø°
                            </button>
                        </form>
                        <p class="text-[10px] text-slate-600 mt-1.5">Enter „ÅßÈÄÅ‰ø° ¬∑ Shift+Enter „ÅßÊîπË°å</p>
                    </div>
                </div>
            </main>

            <!-- Resize handle: right -->
            <div id="resize-handle-right" class="resize-handle"></div>

            <!-- ===== RIGHT PANE: Knowledge Studio ===== -->
            <aside id="right-pane" class="border-l border-white/5 flex flex-col min-h-0 bg-surface-0 overflow-y-auto" style="width: 380px; min-width: 280px; flex-shrink: 0;">
                
                <!-- 1. Knowledge Map + Metrics -->
                <div class="flex-none p-4 border-b border-white/5">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Knowledge Map</h3>
                        <button id="map-detail-btn" class="text-[10px] text-slate-500 hover:text-slate-300 hover:bg-white/5 px-2 py-0.5 rounded transition-colors">Ë©≥Á¥∞</button>
                    </div>
                    <div id="knowledge-map-canvas" class="bg-surface-1 rounded-lg overflow-hidden mb-3"></div>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-surface-2 rounded-lg p-2">
                            <div id="metric-facts" class="text-lg font-semibold text-blue-400">0</div>
                            <div class="text-[10px] text-slate-500">Facts</div>
                        </div>
                        <div class="bg-surface-2 rounded-lg p-2">
                            <div id="metric-tags" class="text-lg font-semibold text-violet-400">0</div>
                            <div class="text-[10px] text-slate-500">Tags</div>
                        </div>
                        <div class="bg-surface-2 rounded-lg p-2">
                            <div id="metric-conflicts" class="text-lg font-semibold text-conflict">0</div>
                            <div class="text-[10px] text-slate-500">ÁüõÁõæ</div>
                        </div>
                    </div>
                </div>

                <!-- 2. Documents Upload (prominent position) -->
                <div class="flex-none p-4 border-b border-white/5">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xs font-medium text-blue-400 uppercase tracking-wider">üìÑ Documents</h3>
                        <span id="documents-count-badge-top" class="text-[10px] text-slate-500">0 files</span>
                    </div>
                    <div 
                        id="upload-dropzone-main"
                        class="border-2 border-dashed border-white/10 rounded-lg p-3 text-center hover:border-blue-400/50 hover:bg-blue-400/5 transition-colors cursor-pointer mb-2"
                    >
                        <input type="file" id="file-input-main" class="hidden" accept=".pdf,.docx,.xlsx,.txt,.md,.json" multiple>
                        <p class="text-xs text-slate-400">üìÅ „Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ</p>
                        <p class="text-[10px] text-slate-600 mt-1">PDF, DOCX, XLSX, TXT, MD, JSON</p>
                    </div>
                    <div id="documents-list-main" class="space-y-2 max-h-48 overflow-y-auto"
                    </div>
                </div>


                <!-- 4. Evidence Ledger (Fact Table) - Collapsible -->
                <div class="flex-1 min-h-0 overflow-hidden flex flex-col border-t border-white/5">
                    <button id="fact-ledger-toggle" class="w-full px-4 py-2.5 flex items-center justify-between text-left hover:bg-surface-2 transition-colors flex-none">
                        <div class="flex items-center gap-2">
                            <span id="fact-ledger-arrow" class="text-[10px] text-slate-500 transition-transform duration-200">‚ñ∂</span>
                            <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Fact Ledger</h3>
                        </div>
                        <span id="fact-count" class="text-[10px] text-slate-500">0 facts</span>
                    </button>
                    <div id="fact-table-wrapper" class="px-4 pb-3 flex-1 min-h-0 overflow-hidden hidden">
                        <div id="fact-table" class="overflow-y-auto space-y-1 h-full">
                            <p class="text-xs text-slate-600 py-4 text-center">„Åæ„Å†Ë®òÈå≤„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                        </div>
                    </div>
                </div>

                <!-- 4. Conflicts (collapsible) -->
                <div id="conflicts-section" class="flex-none border-t border-white/5 hidden">
                    <button id="conflicts-toggle" class="w-full px-4 py-2.5 flex items-center justify-between text-left hover:bg-surface-2 transition-colors">
                        <span class="text-xs font-medium text-conflict">Conflicts</span>
                        <span id="conflicts-count-badge" class="text-xs bg-conflict/20 text-conflict px-1.5 py-0.5 rounded">0</span>
                    </button>
                    <div id="conflicts-list" class="px-4 pb-3 space-y-2 hidden">
                    </div>
                </div>

                <!-- 4.5 Pending Questions (collapsible) -->
                <div id="questions-section" class="flex-none border-t border-white/5 hidden">
                    <button id="questions-toggle" class="w-full px-4 py-2.5 flex items-center justify-between text-left hover:bg-surface-2 transition-colors">
                        <span class="text-xs font-medium text-blue-400">Questions</span>
                        <span id="questions-count-badge" class="text-xs bg-blue-500/20 text-blue-400 px-1.5 py-0.5 rounded">0</span>
                    </button>
                    <div id="questions-list" class="px-4 pb-3 space-y-2 hidden">
                    </div>
                </div>

                <!-- 5. Knowledge Summary (collapsible) - Tags integrated -->
                <div id="knowledge-summary-section" class="flex-none border-t border-white/5">
                    <button id="summary-toggle" class="w-full px-4 py-2.5 flex items-center justify-between text-left hover:bg-surface-2 transition-colors">
                        <div class="flex items-center gap-2">
                            <span id="summary-arrow" class="text-[10px] text-slate-500 transition-transform duration-200">‚ñ∂</span>
                            <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Knowledge Summary</h3>
                        </div>
                        <span id="tags-count-badge" class="text-[10px] text-slate-500">0 tags</span>
                    </button>
                    <div id="summary-panel" class="px-4 pb-3 space-y-3 hidden">
                        <!-- Stats Row -->
                        <div id="knowledge-stats" class="grid grid-cols-3 gap-2 text-center">
                            <div class="bg-surface-2 rounded p-1.5">
                                <div id="stat-facts" class="text-sm font-semibold text-white">0</div>
                                <div class="text-[9px] text-slate-500">Facts</div>
                            </div>
                            <div class="bg-surface-2 rounded p-1.5">
                                <div id="stat-docs" class="text-sm font-semibold text-white">0</div>
                                <div class="text-[9px] text-slate-500">Docs</div>
                            </div>
                            <div class="bg-surface-2 rounded p-1.5">
                                <div id="stat-sessions" class="text-sm font-semibold text-white">0</div>
                                <div class="text-[9px] text-slate-500">Sessions</div>
                            </div>
                        </div>
                        
                        <!-- Tags Section (integrated) -->
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <p class="text-[10px] text-emerald-400 font-medium">üè∑Ô∏è Tags</p>
                                <div class="flex gap-1">
                                    <button id="add-tag-btn" class="text-[10px] text-slate-500 hover:text-emerald-400 transition-colors">+ ËøΩÂä†</button>
                                    <span class="text-slate-600">¬∑</span>
                                    <button id="manage-tags-btn" class="text-[10px] text-slate-500 hover:text-emerald-400 transition-colors">ÁÆ°ÁêÜ</button>
                                </div>
                            </div>
                            <div id="tag-cloud" class="flex flex-wrap gap-1.5">
                                <span class="text-xs text-slate-600">„Çø„Ç∞„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</span>
                            </div>
                        </div>
                        
                        <!-- Summary Generation -->
                        <button 
                            id="generate-summary-btn"
                            class="w-full py-1.5 text-xs bg-purple-600 hover:bg-purple-700 text-white rounded transition-colors"
                        >
                            üîç „Çµ„Éû„É™„ÉºÁîüÊàê
                        </button>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- ===== Knowledge Map Fullscreen Modal ===== -->
    <div id="knowledge-map-modal" class="fixed inset-0 z-50 hidden">
        <!-- Backdrop -->
        <div id="km-modal-backdrop" class="absolute inset-0 bg-black/70 backdrop-blur-sm"></div>
        <!-- Content -->
        <div class="absolute inset-0 flex items-center justify-center p-8 pointer-events-none">
            <div id="km-modal-content" class="relative bg-surface-1 rounded-2xl border border-white/10 shadow-2xl pointer-events-auto"
                 style="width: 80vw; height: 75vh; max-width: 1200px; max-height: 900px;">
                <!-- Header -->
                <div class="absolute top-0 left-0 right-0 flex items-center justify-between px-5 py-3 z-10">
                    <h2 class="text-sm font-semibold text-slate-300 uppercase tracking-wider">Knowledge Map</h2>
                    <button id="km-modal-close" class="text-slate-500 hover:text-white transition-colors p-1 rounded-lg hover:bg-white/10">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
                <!-- Map Canvas -->
                <div id="km-modal-canvas" class="w-full h-full rounded-2xl overflow-hidden"></div>
                <!-- Metrics Bar (bottom) -->
                <div class="absolute bottom-0 left-0 right-0 flex items-center justify-center gap-6 px-5 py-3 z-10 bg-gradient-to-t from-black/40 to-transparent rounded-b-2xl">
                    <div class="text-center">
                        <span id="km-modal-facts" class="text-lg font-semibold text-blue-400">0</span>
                        <span class="text-[10px] text-slate-400 ml-1">Facts</span>
                    </div>
                    <div class="text-center">
                        <span id="km-modal-tags" class="text-lg font-semibold text-violet-400">0</span>
                        <span class="text-[10px] text-slate-400 ml-1">Tags</span>
                    </div>
                    <div class="text-center">
                        <span id="km-modal-conflicts" class="text-lg font-semibold text-conflict">0</span>
                        <span class="text-[10px] text-slate-400 ml-1">ÁüõÁõæ</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =====================================================
        // Simplex Noise for organic particle movement
        // =====================================================
        class SimplexNoise {
            constructor() {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }
            
            noise3D(x, y, z) {
                const F3 = 1/3, G3 = 1/6;
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
                const t = (i + j + k) * G3;
                const X0 = i - t, Y0 = j - t, Z0 = k - t;
                const x0 = x - X0, y0 = y - Y0, z0 = z - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                
                const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2*G3, y2 = y0 - j2 + 2*G3, z2 = z0 - k2 + 2*G3;
                const x3 = x0 - 1 + 3*G3, y3 = y0 - 1 + 3*G3, z3 = z0 - 1 + 3*G3;
                
                const ii = i & 255, jj = j & 255, kk = k & 255;
                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                
                const dot = (g, x, y, z) => g[0]*x + g[1]*y + g[2]*z;
                const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
                const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
                const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
                const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
                
                let n0 = 0, n1 = 0, n2 = 0, n3 = 0;
                let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0); }
                let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1); }
                let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2); }
                let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                if (t3 > 0) { t3 *= t3; n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3); }
                
                return 32 * (n0 + n1 + n2 + n3);
            }
        }

        // =====================================================
        // Knowledge Map - Organic Particle Sphere with Tag Data
        // =====================================================
        class KnowledgeMap {
            constructor(container) {
                this.container = container;
                this.particleCount = 4000;
                this.radius = 80;
                this.noise = new SimplexNoise();
                this.time = 0;
                this.flashTimer = 0;
                this.flashColor = null;
                
                // Tag data
                this.tagNodes = [];
                this.tagNodeMap = {}; // Map of tag id -> tag node
                this.hoveredTag = null;
                this.tooltip = null;
                this.connectionLines = null; // Legacy
                this.connectionLinesGroup = null; // Lines showing tag connections
                
                // Tag animation state
                this.tagAnimating = false;
                this.tagAnimStartTime = 0;
                this.tagAnimDuration = 1500;
                
                // Zoom settings
                this.zoomMin = this.radius * 1.5;  // Close zoom
                this.zoomMax = this.radius * 4;    // Far zoom
                this.zoomSpeed = 0.1;
                this.targetZoom = this.radius * 2.8;
                
                // Touch pinch
                this.lastPinchDist = 0;
                
                // Drag rotation
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.targetRotationX = 0;
                this.targetRotationY = 0;
                this.autoRotate = true; // Auto-rotate when not dragging
                
                this.init();
                this.loadTagData();
            }
            
            init() {
                this.scene = new THREE.Scene();
                
                const rect = this.container.getBoundingClientRect();
                this.camera = new THREE.PerspectiveCamera(50, rect.width / rect.height, 0.1, 1000);
                this.camera.position.z = this.radius * 2.8;
                
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.setSize(rect.width, rect.height);
                this.renderer.domElement.style.cursor = 'grab';
                this.container.appendChild(this.renderer.domElement);
                
                // Raycaster for hover detection
                this.raycaster = new THREE.Raycaster();
                this.raycaster.params.Points.threshold = 8;
                this.mouse = new THREE.Vector2();
                
                this.circleTexture = this.createCircleTexture();
                this.glowCircleTexture = this.createCircleTexture(true);
                this.createParticles();
                this.createTooltip();
                
                // Event listeners
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('mouseleave', () => this.onMouseLeave());
                window.addEventListener('resize', () => this.handleResize());
                
                // Watch container size changes (e.g. sidebar resize)
                if (typeof ResizeObserver !== 'undefined') {
                    this._resizeObserver = new ResizeObserver(() => this.handleResize());
                    this._resizeObserver.observe(this.container);
                }
                
                // Drag rotation: mouse
                this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.renderer.domElement.addEventListener('mouseup', () => this.onMouseUp());
                
                // Zoom: mouse wheel
                this.renderer.domElement.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
                
                // Touch: drag rotation (1 finger) + pinch zoom (2 fingers)
                this.renderer.domElement.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                this.renderer.domElement.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                this.renderer.domElement.addEventListener('touchend', () => this.onTouchEnd());
                
                this.animate();
            }
            
            onWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 1 : -1;
                this.targetZoom = Math.max(this.zoomMin, Math.min(this.zoomMax, 
                    this.targetZoom + delta * this.radius * this.zoomSpeed));
            }
            
            onMouseDown(e) {
                this.isDragging = true;
                this.autoRotate = false;
                this.dragStart.x = e.clientX;
                this.dragStart.y = e.clientY;
                this.renderer.domElement.style.cursor = 'grabbing';
            }
            
            onMouseUp() {
                this.isDragging = false;
                this.renderer.domElement.style.cursor = 'grab';
                // Resume auto-rotate after 3 seconds of no interaction
                setTimeout(() => {
                    if (!this.isDragging) {
                        this.autoRotate = true;
                    }
                }, 3000);
            }
            
            onTouchStart(e) {
                if (e.touches.length === 1) {
                    // Single finger: drag rotation
                    this.isDragging = true;
                    this.autoRotate = false;
                    this.dragStart.x = e.touches[0].clientX;
                    this.dragStart.y = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    // Two fingers: pinch zoom
                    e.preventDefault();
                    this.isDragging = false;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    this.lastPinchDist = Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            onTouchMove(e) {
                if (e.touches.length === 1 && this.isDragging) {
                    // Single finger: drag rotation
                    const deltaX = e.touches[0].clientX - this.dragStart.x;
                    const deltaY = e.touches[0].clientY - this.dragStart.y;
                    
                    this.targetRotationY += deltaX * 0.005;
                    this.targetRotationX += deltaY * 0.005;
                    
                    // Limit vertical rotation
                    this.targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.targetRotationX));
                    
                    this.dragStart.x = e.touches[0].clientX;
                    this.dragStart.y = e.touches[0].clientY;
                    
                    this.hideTooltip();
                    this.hideConnectionLines();
                } else if (e.touches.length === 2 && this.lastPinchDist > 0) {
                    // Two fingers: pinch zoom
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    const delta = (this.lastPinchDist - dist) * 0.5;
                    this.targetZoom = Math.max(this.zoomMin, Math.min(this.zoomMax, 
                        this.targetZoom + delta));
                    
                    this.lastPinchDist = dist;
                }
            }
            
            onTouchEnd() {
                this.isDragging = false;
                this.lastPinchDist = 0;
                // Resume auto-rotate after 3 seconds
                setTimeout(() => {
                    if (!this.isDragging) {
                        this.autoRotate = true;
                    }
                }, 3000);
            }
            
            async loadTagData() {
                try {
                    const response = await fetch('/api/knowledge-graph?limit=500');
                    if (!response.ok) return;
                    
                    const data = await response.json();
                    if (data.nodes.length === 0) return;
                    
                    // Build adjacency map and calculate connection counts
                    const connectionCount = {};
                    const adjacency = {};
                    data.nodes.forEach(n => {
                        connectionCount[n.id] = 0;
                        adjacency[n.id] = [];
                    });
                    
                    data.edges.forEach(e => {
                        connectionCount[e.source] = (connectionCount[e.source] || 0) + e.co_occurrence_count;
                        connectionCount[e.target] = (connectionCount[e.target] || 0) + e.co_occurrence_count;
                        adjacency[e.source] = adjacency[e.source] || [];
                        adjacency[e.target] = adjacency[e.target] || [];
                        adjacency[e.source].push({ id: e.target, weight: e.co_occurrence_count });
                        adjacency[e.target].push({ id: e.source, weight: e.co_occurrence_count });
                    });
                    
                    // Calculate centrality score using LOG SCALE for clear differentiation
                    // Without log, a tag with usage=241 would make all tags with usage=1-5 look identical
                    const usages = data.nodes.map(n => n.usage_count);
                    const connValues = Object.values(connectionCount);
                    const maxLogUsage = Math.log(1 + Math.max(...usages, 1));
                    const maxLogConn = Math.log(1 + Math.max(...connValues, 1));
                    
                    // Remember previous positions for animation
                    const prevPositions = {};
                    this.tagNodes.forEach(t => {
                        prevPositions[t.id] = { x: t.baseX, y: t.baseY, z: t.baseZ };
                    });
                    const prevIds = new Set(this.tagNodes.map(t => t.id));
                    
                    // Initialize positions using force-directed layout on sphere
                    const nodes = data.nodes.map((n, i) => {
                        // Log scale: log(1+x) / log(1+max) spreads values more evenly
                        const usageScore = Math.log(1 + n.usage_count) / maxLogUsage;
                        const connScore = Math.log(1 + (connectionCount[n.id] || 0)) / maxLogConn;
                        const centrality = usageScore * 0.4 + connScore * 0.6;
                        
                        // If tag existed before, use its previous position as start
                        const prev = prevPositions[n.id];
                        let x, y, z;
                        if (prev) {
                            // Normalize previous position back to unit sphere
                            const len = Math.sqrt(prev.x*prev.x + prev.y*prev.y + prev.z*prev.z) || 1;
                            x = prev.x / len;
                            y = prev.y / len;
                            z = prev.z / len;
                        } else {
                            // New tag: initial position using golden angle
                            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                            const theta = goldenAngle * i;
                            const phi = Math.acos(1 - 2 * (i + 0.5) / data.nodes.length);
                            x = Math.sin(phi) * Math.cos(theta);
                            y = Math.cos(phi);
                            z = Math.sin(phi) * Math.sin(theta);
                        }
                        
                        return {
                            ...n,
                            centrality,
                            usageScore,
                            connScore,
                            connections: adjacency[n.id] || [],
                            x, y, z,
                            isNew: !prevIds.has(n.id),
                        };
                    });
                    
                    // Force-directed simulation on sphere surface
                    this.runForceSimulation(nodes, data.edges);
                    
                    // Convert to final target positions
                    const newTagNodes = nodes.map(n => {
                        const rFactor = 0.85 + n.centrality * 0.15;
                        const r = this.radius * rFactor;
                        const targetX = n.x * r;
                        const targetY = n.y * r;
                        const targetZ = n.z * r;
                        
                        // For existing tags: animate from current to target
                        // For new tags: animate from center (birth) to target
                        const prev = prevPositions[n.id];
                        const startX = prev ? prev.x : 0;
                        const startY = prev ? prev.y : 0;
                        const startZ = prev ? prev.z : 0;
                        
                        return {
                            ...n,
                            r,
                            // Current (animated) positions ‚Äî start from previous
                            baseX: startX,
                            baseY: startY,
                            baseZ: startZ,
                            // Target (final) positions
                            targetX, targetY, targetZ,
                            // Animation progress: 0 = start, 1 = done
                            animProgress: 0,
                            // New tag birth animation
                            isNew: n.isNew,
                            birthScale: n.isNew ? 0 : 1,
                        };
                    });
                    
                    this.tagNodes = newTagNodes;
                    
                    // Build map for quick lookup
                    this.tagNodeMap = {};
                    this.tagNodes.forEach(t => this.tagNodeMap[t.id] = t);
                    
                    // Trigger animated transition
                    this.tagAnimating = true;
                    this.tagAnimStartTime = performance.now();
                    this.tagAnimDuration = 1500; // 1.5 seconds
                    
                    this.createTagParticles();
                } catch (error) {
                    console.error('Failed to load tag data:', error);
                }
            }
            
            runForceSimulation(nodes, edges) {
                // Force-directed layout ‚Äî connected tags cluster together
                const iterations = 200;
                const attractionStrength = 0.06;
                const repulsionStrength = 0.003;
                
                // Build edge map with weights
                const edgeMap = {};
                edges.forEach(e => {
                    const key1 = `${e.source}-${e.target}`;
                    const key2 = `${e.target}-${e.source}`;
                    edgeMap[key1] = e.co_occurrence_count;
                    edgeMap[key2] = e.co_occurrence_count;
                });
                
                const nodeMap = {};
                nodes.forEach(n => nodeMap[n.id] = n);
                
                for (let iter = 0; iter < iterations; iter++) {
                    const temperature = Math.pow(1 - iter / iterations, 1.5); // Smoother cooling
                    
                    // Calculate forces for each node
                    nodes.forEach(node => {
                        let fx = 0, fy = 0, fz = 0;
                        
                        // Repulsion from all other nodes
                        nodes.forEach(other => {
                            if (node.id === other.id) return;
                            
                            const dx = node.x - other.x;
                            const dy = node.y - other.y;
                            const dz = node.z - other.z;
                            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.01;
                            
                            // Repulsion force (inverse square)
                            const repForce = repulsionStrength / (dist * dist);
                            fx += (dx / dist) * repForce;
                            fy += (dy / dist) * repForce;
                            fz += (dz / dist) * repForce;
                        });
                        
                        // Attraction to connected nodes ‚Äî stronger for higher co-occurrence
                        node.connections.forEach(conn => {
                            const other = nodeMap[conn.id];
                            if (!other) return;
                            
                            const dx = other.x - node.x;
                            const dy = other.y - node.y;
                            const dz = other.z - node.z;
                            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.01;
                            
                            // Attraction proportional to co-occurrence (stronger pull)
                            const attForce = attractionStrength * Math.log(1 + conn.weight * 2);
                            fx += (dx / dist) * attForce * dist; // Proportional to distance
                            fy += (dy / dist) * attForce * dist;
                            fz += (dz / dist) * attForce * dist;
                        });
                        
                        node.fx = fx * temperature;
                        node.fy = fy * temperature;
                        node.fz = fz * temperature;
                    });
                    
                    // Apply forces and project back to sphere
                    nodes.forEach(node => {
                        node.x += node.fx;
                        node.y += node.fy;
                        node.z += node.fz;
                        
                        // Normalize to sphere surface
                        const len = Math.sqrt(node.x*node.x + node.y*node.y + node.z*node.z) || 1;
                        node.x /= len;
                        node.y /= len;
                        node.z /= len;
                    });
                }
            }
            
            createCircleTexture(glow = false) {
                const size = 128;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const center = size / 2;
                const radius = size / 2;
                
                if (glow) {
                    // Solid circle with crisp anti-aliased edge for tag particles
                    const gradient = ctx.createRadialGradient(center, center, 0, center, center, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                    gradient.addColorStop(0.55, 'rgba(255, 255, 255, 1.0)');
                    gradient.addColorStop(0.75, 'rgba(255, 255, 255, 0.6)');
                    gradient.addColorStop(0.9, 'rgba(255, 255, 255, 0.1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, size, size);
                } else {
                    // Clean circle for background particles
                    const gradient = ctx.createRadialGradient(center, center, 0, center, center, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(0.75, 'rgba(255, 255, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, size, size);
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            }
            
            createParticles() {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const basePositions = new Float32Array(this.particleCount * 3);
                const colors = new Float32Array(this.particleCount * 3);
                const phases = new Float32Array(this.particleCount);
                const depths = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    let rNorm;
                    if (Math.random() < 0.7) {
                        rNorm = 0.8 + Math.random() * 0.2;
                    } else {
                        rNorm = Math.pow(Math.random(), 1/3) * 0.8;
                    }
                    
                    const r = this.radius * rNorm;
                    const depth = rNorm;
                    
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.cos(phi);
                    const z = r * Math.sin(phi) * Math.sin(theta);
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    
                    basePositions[i * 3] = x;
                    basePositions[i * 3 + 1] = y;
                    basePositions[i * 3 + 2] = z;
                    
                    depths[i] = depth;
                    
                    const colorVariation = Math.random() * 0.2;
                    const depthFade = 0.5 + depth * 0.5;
                    colors[i * 3] = (0.2 + colorVariation * 0.3) * depthFade;
                    colors[i * 3 + 1] = (0.5 + colorVariation) * depthFade;
                    colors[i * 3 + 2] = (0.85 + Math.random() * 0.15) * depthFade;
                    
                    phases[i] = Math.random() * Math.PI * 2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('basePosition', new THREE.BufferAttribute(basePositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 2.0,
                    map: this.circleTexture,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.75,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            // Importance color: multi-stop gradient for clearer differentiation
            // t=0 (low importance) = Blue, t=1 (high importance) = Red
            getImportanceColor(t) {
                // 5-stop gradient: Deep Blue ‚Üí Blue ‚Üí Purple ‚Üí Orange-Red ‚Üí Bright Red
                const stops = [
                    { t: 0.0, r: 0.15, g: 0.25, b: 1.0  },  // Deep blue
                    { t: 0.25, r: 0.2,  g: 0.4,  b: 0.95 },  // Blue
                    { t: 0.5,  r: 0.6,  g: 0.15, b: 0.7  },  // Purple
                    { t: 0.75, r: 0.95, g: 0.3,  b: 0.15 },  // Orange-Red
                    { t: 1.0,  r: 1.0,  g: 0.15, b: 0.1  },  // Bright Red
                ];
                
                // Find the two stops to interpolate between
                let low = stops[0], high = stops[stops.length - 1];
                for (let i = 0; i < stops.length - 1; i++) {
                    if (t >= stops[i].t && t <= stops[i + 1].t) {
                        low = stops[i];
                        high = stops[i + 1];
                        break;
                    }
                }
                
                const range = high.t - low.t || 1;
                const f = (t - low.t) / range;
                // Smooth interpolation
                const sf = f * f * (3 - 2 * f);
                
                return {
                    r: low.r + (high.r - low.r) * sf,
                    g: low.g + (high.g - low.g) * sf,
                    b: low.b + (high.b - low.b) * sf,
                };
            }
            
            createTagParticles() {
                if (this.tagPoints) {
                    this.scene.remove(this.tagPoints);
                }
                
                if (this.tagNodes.length === 0) return;
                
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.tagNodes.length * 3);
                const colors = new Float32Array(this.tagNodes.length * 3);
                const sizes = new Float32Array(this.tagNodes.length);
                
                this.tagNodes.forEach((tag, i) => {
                    positions[i * 3] = tag.baseX;
                    positions[i * 3 + 1] = tag.baseY;
                    positions[i * 3 + 2] = tag.baseZ;
                    
                    const t = tag.centrality; // 0 = low importance (blue), 1 = high importance (red)
                    const c = this.getImportanceColor(t);
                    
                    // Brightness boost so particles are vivid
                    const brightness = 0.85 + t * 0.15;
                    colors[i * 3]     = c.r * brightness;
                    colors[i * 3 + 1] = c.g * brightness;
                    colors[i * 3 + 2] = c.b * brightness;
                    
                    // Size scales with importance ‚Äî larger for more important tags
                    sizes[i] = 3.0 + t * 7.0; // 3 ~ 10
                });
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Custom ShaderMaterial so each particle can have its own size + color
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        pointTexture: { value: this.glowCircleTexture },
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D pointTexture;
                        varying vec3 vColor;
                        void main() {
                            vec4 texColor = texture2D(pointTexture, gl_PointCoord);
                            if (texColor.a < 0.01) discard;
                            gl_FragColor = vec4(vColor * texColor.rgb, texColor.a);
                        }
                    `,
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    depthTest: true,
                    transparent: true,
                });
                
                this.tagPoints = new THREE.Points(geometry, material);
                this.scene.add(this.tagPoints);
            }
            
            createTooltip() {
                this.tooltip = document.createElement('div');
                this.tooltip.style.cssText = `
                    position: fixed;
                    visibility: hidden;
                    background: rgba(22, 24, 29, 0.95);
                    border: 1px solid rgba(76, 201, 240, 0.3);
                    border-radius: 8px;
                    padding: 10px 14px;
                    font-size: 12px;
                    color: #e2e8f0;
                    pointer-events: none;
                    z-index: 10000;
                    backdrop-filter: blur(8px);
                    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                `;
                document.body.appendChild(this.tooltip);
            }
            
            onMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                
                // Handle drag rotation
                if (this.isDragging) {
                    const deltaX = event.clientX - this.dragStart.x;
                    const deltaY = event.clientY - this.dragStart.y;
                    
                    this.targetRotationY += deltaX * 0.005;
                    this.targetRotationX += deltaY * 0.005;
                    
                    // Limit vertical rotation
                    this.targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.targetRotationX));
                    
                    this.dragStart.x = event.clientX;
                    this.dragStart.y = event.clientY;
                    
                    // Hide tooltip while dragging
                    this.hideTooltip();
                    this.hideConnectionLines();
                    return;
                }
                
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                if (this.tagPoints && this.tagNodes.length > 0) {
                    // Screen-space hit test: project each tag to screen, find nearest
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    const w = rect.width;
                    const h = rect.height;
                    
                    let closestTag = null;
                    let closestDist = Infinity;
                    const hitRadius = 20; // pixels ‚Äî generous hover area
                    
                    const tempVec = new THREE.Vector3();
                    
                    for (let i = 0; i < this.tagNodes.length; i++) {
                        const tag = this.tagNodes[i];
                        const pos = this.getTagDisplayPos(tag);
                        
                        // Apply tagPoints rotation to get world position
                        tempVec.set(pos.x, pos.y, pos.z);
                        if (this.tagPoints) {
                            tempVec.applyMatrix4(this.tagPoints.matrixWorld);
                        }
                        
                        // Project to screen
                        tempVec.project(this.camera);
                        const sx = (tempVec.x * 0.5 + 0.5) * w;
                        const sy = (-tempVec.y * 0.5 + 0.5) * h;
                        
                        // Skip points behind camera
                        if (tempVec.z > 1) continue;
                        
                        const dx = mouseX - sx;
                        const dy = mouseY - sy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Larger hitbox for more important tags
                        const tagHitRadius = hitRadius + tag.centrality * 10;
                        
                        if (dist < tagHitRadius && dist < closestDist) {
                            closestDist = dist;
                            closestTag = tag;
                        }
                    }
                    
                    if (closestTag) {
                        if (closestTag !== this.hoveredTag) {
                            this.hoveredTag = closestTag;
                            this.showTooltip(event, closestTag);
                            this.showConnectionLines(closestTag);
                        } else {
                            this.moveTooltip(event);
                        }
                    } else {
                        if (this.hoveredTag) {
                            this.hideTooltip();
                            this.hideConnectionLines();
                        }
                    }
                }
            }
            
            onMouseLeave() {
                this.hideTooltip();
                this.hideConnectionLines();
            }
            
            // Get current display position of a tag (accounts for animation)
            getTagDisplayPos(tag) {
                if (this.tagAnimating && tag.targetX !== undefined) {
                    const now = performance.now();
                    const elapsed = now - this.tagAnimStartTime;
                    const rawT = Math.min(elapsed / this.tagAnimDuration, 1);
                    const easeT = 1 - Math.pow(1 - rawT, 3);
                    return {
                        x: tag.baseX + (tag.targetX - tag.baseX) * easeT,
                        y: tag.baseY + (tag.targetY - tag.baseY) * easeT,
                        z: tag.baseZ + (tag.targetZ - tag.baseZ) * easeT,
                    };
                }
                return { x: tag.baseX, y: tag.baseY, z: tag.baseZ };
            }
            
            showConnectionLines(tag) {
                this.hideConnectionLines(); // Remove existing lines
                
                if (!tag.connections || tag.connections.length === 0) return;
                
                this.connectionLinesGroup = new THREE.Group();
                
                const positions = [];
                const colors = [];
                
                const srcColor = this.getImportanceColor(tag.centrality);
                const srcPos = this.getTagDisplayPos(tag);
                
                tag.connections.forEach(conn => {
                    const targetTag = this.tagNodeMap[conn.id];
                    if (!targetTag) return;
                    
                    const tgtColor = this.getImportanceColor(targetTag.centrality);
                    const tgtPos = this.getTagDisplayPos(targetTag);
                    
                    // Line from source to target
                    positions.push(srcPos.x, srcPos.y, srcPos.z);
                    positions.push(tgtPos.x, tgtPos.y, tgtPos.z);
                    
                    // Gradient from source importance color to target importance color
                    // Brighten for visibility
                    const boost = 0.3;
                    colors.push(
                        Math.min(1, srcColor.r + boost),
                        Math.min(1, srcColor.g + boost),
                        Math.min(1, srcColor.b + boost)
                    );
                    colors.push(
                        Math.min(1, tgtColor.r + boost),
                        Math.min(1, tgtColor.g + boost),
                        Math.min(1, tgtColor.b + boost)
                    );
                });
                
                if (positions.length === 0) return;
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                // Soft glow layer
                const glowMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                });
                const glowLines = new THREE.LineSegments(geometry.clone(), glowMaterial);
                glowLines.renderOrder = 10;
                this.connectionLinesGroup.add(glowLines);
                
                // Main bright line
                const mainMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                });
                const mainLines = new THREE.LineSegments(geometry, mainMaterial);
                mainLines.renderOrder = 11;
                this.connectionLinesGroup.add(mainLines);
                
                // Add glowing dot at connection endpoints
                tag.connections.forEach(conn => {
                    const targetTag = this.tagNodeMap[conn.id];
                    if (!targetTag) return;
                    
                    const tPos = this.getTagDisplayPos(targetTag);
                    const tc = this.getImportanceColor(targetTag.centrality);
                    const dotGeo = new THREE.SphereGeometry(0.6, 12, 12);
                    const dotMat = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(
                            Math.min(1, tc.r + 0.2),
                            Math.min(1, tc.g + 0.2),
                            Math.min(1, tc.b + 0.2)
                        ),
                        transparent: true,
                        opacity: 0.85,
                        blending: THREE.AdditiveBlending,
                        depthTest: false,
                    });
                    const dot = new THREE.Mesh(dotGeo, dotMat);
                    dot.position.set(tPos.x, tPos.y, tPos.z);
                    dot.renderOrder = 12;
                    this.connectionLinesGroup.add(dot);
                });
                
                // Highlight dot at source
                const sc = this.getImportanceColor(tag.centrality);
                const srcDotGeo = new THREE.SphereGeometry(0.8, 12, 12);
                const srcDotMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(
                        Math.min(1, sc.r + 0.3),
                        Math.min(1, sc.g + 0.3),
                        Math.min(1, sc.b + 0.3)
                    ),
                    transparent: true,
                    opacity: 0.95,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                });
                const srcDot = new THREE.Mesh(srcDotGeo, srcDotMat);
                srcDot.position.set(srcPos.x, srcPos.y, srcPos.z);
                srcDot.renderOrder = 12;
                this.connectionLinesGroup.add(srcDot);
                
                // Sync rotation with particles
                if (this.particles) {
                    this.connectionLinesGroup.rotation.copy(this.particles.rotation);
                }
                this.scene.add(this.connectionLinesGroup);
            }
            
            hideConnectionLines() {
                if (this.connectionLinesGroup) {
                    this.connectionLinesGroup.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    this.scene.remove(this.connectionLinesGroup);
                    this.connectionLinesGroup = null;
                }
            }
            
            showTooltip(event, tag) {
                // Generate color matching the importance gradient
                const t = tag.centrality;
                const c = this.getImportanceColor(t);
                const r = Math.round(c.r * 255);
                const g = Math.round(c.g * 255);
                const b = Math.round(c.b * 255);
                const tagColor = `rgb(${r}, ${g}, ${b})`;
                
                // Centrality label with importance levels
                let centralityLabel = '';
                if (t > 0.75) centralityLabel = 'ÈáçË¶ÅÂ∫¶: ÊúÄÈ´ò';
                else if (t > 0.5) centralityLabel = 'ÈáçË¶ÅÂ∫¶: È´ò';
                else if (t > 0.25) centralityLabel = 'ÈáçË¶ÅÂ∫¶: ‰∏≠';
                else centralityLabel = 'ÈáçË¶ÅÂ∫¶: ‰Ωé';
                
                const content = `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                        <div style="width: 10px; height: 10px; border-radius: 50%; background: ${tagColor}; box-shadow: 0 0 6px ${tagColor};"></div>
                        <span style="font-weight: 600; font-size: 13px; color: #fff;">${tag.name}</span>
                    </div>
                    <div style="color: #94a3b8; font-size: 11px; margin-bottom: 4px;">
                        ${tag.insight_count > 0 ? `„Ç§„É≥„Çµ„Ç§„Éà: ${tag.insight_count}` : ''}
                        ${tag.insight_count > 0 && tag.document_count > 0 ? ' / ' : ''}
                        ${tag.document_count > 0 ? `„Éâ„Ç≠„É•„É°„É≥„Éà: ${tag.document_count}` : ''}
                    </div>
                    <div style="color: ${tagColor}; font-size: 10px; font-weight: 500;">${centralityLabel}</div>
                `;
                this.tooltip.innerHTML = content;
                this.tooltip.style.visibility = 'visible';
                this.moveTooltip(event);
            }
            
            moveTooltip(event) {
                this.tooltip.style.left = `${event.clientX + 12}px`;
                this.tooltip.style.top = `${event.clientY - 10}px`;
            }
            
            hideTooltip() {
                this.hoveredTag = null;
                this.tooltip.style.visibility = 'hidden';
            }
            
            handleResize() {
                const rect = this.container.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;
                this.camera.aspect = rect.width / rect.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(rect.width, rect.height);
            }
            
            // Public alias for external callers
            resize() {
                this.handleResize();
            }
            
            onFactVerified(count = 1) {
                this.flashTimer = 2.0;
                this.flashColor = [0.29, 0.87, 0.5];
                setTimeout(() => this.loadTagData(), 1500);
            }
            
            onConflict() {
                this.flashTimer = 2.5;
                this.flashColor = [0.97, 0.27, 0.27];
                setTimeout(() => this.loadTagData(), 1500);
            }
            
            onRelationAdded() {
                this.flashTimer = 1.5;
                this.flashColor = [0.4, 0.8, 1.0];
                this.loadTagData();
            }
            
            lerp(a, b, t) { return a + (b - a) * t; }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Smooth zoom interpolation
                this.camera.position.z = this.lerp(this.camera.position.z, this.targetZoom, 0.08);
                
                this.time += 0.006;
                const geometry = this.particles.geometry;
                const positions = geometry.attributes.position.array;
                const basePositions = geometry.attributes.basePosition.array;
                const colors = geometry.attributes.color.array;
                const phases = geometry.attributes.phase.array;
                const depths = geometry.attributes.depth.array;
                
                // Auto-rotate when not dragging
                if (this.autoRotate) {
                    this.targetRotationY += 0.0004;
                }
                
                // Smooth rotation interpolation
                this.particles.rotation.y = this.lerp(this.particles.rotation.y, this.targetRotationY, 0.1);
                this.particles.rotation.x = this.lerp(this.particles.rotation.x, this.targetRotationX, 0.1);
                
                if (this.tagPoints) {
                    this.tagPoints.rotation.y = this.particles.rotation.y;
                    this.tagPoints.rotation.x = this.particles.rotation.x;
                    this.tagPoints.updateMatrixWorld(true);
                }
                
                // Sync connection lines rotation
                if (this.connectionLinesGroup) {
                    this.connectionLinesGroup.rotation.y = this.particles.rotation.y;
                    this.connectionLinesGroup.rotation.x = this.particles.rotation.x;
                }
                
                if (this.flashTimer > 0) {
                    this.flashTimer -= 0.016;
                }
                
                const waveSpeed = 0.1;
                const waveAmount = 4;
                const noiseAmount = 6;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    const phase = phases[i];
                    const depth = depths[i];
                    
                    const bx = basePositions[i3];
                    const by = basePositions[i3 + 1];
                    const bz = basePositions[i3 + 2];
                    
                    const len = Math.sqrt(bx*bx + by*by + bz*bz) || 1;
                    const nx = bx / len;
                    const ny = by / len;
                    const nz = bz / len;
                    
                    const depthFactor = 0.3 + depth * 0.7;
                    
                    const wave1 = Math.sin(this.time * waveSpeed + phase + ny * 4) * waveAmount * 0.5 * depthFactor;
                    const wave2 = Math.sin(this.time * waveSpeed * 0.7 + phase * 1.3 + nx * 3) * waveAmount * 0.3 * depthFactor;
                    
                    const noiseVal = this.noise.noise3D(
                        nx * 2 + this.time * 0.2,
                        ny * 2 + this.time * 0.15,
                        nz * 2 + this.time * 0.18
                    ) * noiseAmount * depthFactor;
                    
                    const displacement = wave1 + wave2 + noiseVal;
                    const scale = 1 + displacement / this.radius;
                    
                    positions[i3] = bx * scale;
                    positions[i3 + 1] = by * scale;
                    positions[i3 + 2] = bz * scale;
                    
                    let r = 0.2 + (i % 3) * 0.05;
                    let g = 0.5 + depth * 0.2;
                    let b = 0.85;
                    
                    const depthBrightness = 0.5 + depth * 0.5;
                    r *= depthBrightness;
                    g *= depthBrightness;
                    b *= depthBrightness;
                    
                    const shimmer = (displacement / (waveAmount + noiseAmount + 0.1)) * 0.2;
                    r += shimmer * 0.3;
                    g += shimmer * 0.5;
                    b += shimmer * 0.7;
                    
                    if (this.flashTimer > 0 && this.flashColor) {
                        const flashT = Math.pow(this.flashTimer / 2.5, 2) * 0.5;
                        r = this.lerp(r, this.flashColor[0], flashT);
                        g = this.lerp(g, this.flashColor[1], flashT);
                        b = this.lerp(b, this.flashColor[2], flashT);
                    }
                    
                    colors[i3] = Math.max(0, Math.min(1, r));
                    colors[i3 + 1] = Math.max(0, Math.min(1, g));
                    colors[i3 + 2] = Math.max(0, Math.min(1, b));
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                
                // ---- Tag particle animation (position lerp + birth scale) ----
                if (this.tagAnimating && this.tagPoints && this.tagNodes.length > 0) {
                    const now = performance.now();
                    const elapsed = now - this.tagAnimStartTime;
                    const rawT = Math.min(elapsed / this.tagAnimDuration, 1);
                    // Ease out cubic for smooth deceleration
                    const easeT = 1 - Math.pow(1 - rawT, 3);
                    
                    const tagGeo = this.tagPoints.geometry;
                    const tagPos = tagGeo.attributes.position.array;
                    const tagSizes = tagGeo.attributes.size.array;
                    
                    this.tagNodes.forEach((tag, i) => {
                        // Lerp position from start to target
                        const cx = tag.baseX + (tag.targetX - tag.baseX) * easeT;
                        const cy = tag.baseY + (tag.targetY - tag.baseY) * easeT;
                        const cz = tag.baseZ + (tag.targetZ - tag.baseZ) * easeT;
                        
                        tagPos[i * 3]     = cx;
                        tagPos[i * 3 + 1] = cy;
                        tagPos[i * 3 + 2] = cz;
                        
                        // Birth animation for new tags: scale from 0 to full
                        if (tag.isNew) {
                            // Delayed start for new tags (appear after 30% of animation)
                            const birthT = Math.max(0, (rawT - 0.3) / 0.7);
                            const birthEase = 1 - Math.pow(1 - birthT, 2);
                            tag.birthScale = birthEase;
                            const baseSize = 3.0 + tag.centrality * 7.0;
                            // Overshoot effect: grows slightly larger then settles
                            const overshoot = birthT < 1 ? (1 + 0.3 * Math.sin(birthT * Math.PI)) : 1;
                            tagSizes[i] = baseSize * birthEase * overshoot;
                        }
                    });
                    
                    tagGeo.attributes.position.needsUpdate = true;
                    tagGeo.attributes.size.needsUpdate = true;
                    
                    // When animation completes, snap to final positions
                    if (rawT >= 1) {
                        this.tagAnimating = false;
                        this.tagNodes.forEach((tag, i) => {
                            tag.baseX = tag.targetX;
                            tag.baseY = tag.targetY;
                            tag.baseZ = tag.targetZ;
                            tag.isNew = false;
                            tag.birthScale = 1;
                            tagPos[i * 3]     = tag.baseX;
                            tagPos[i * 3 + 1] = tag.baseY;
                            tagPos[i * 3 + 2] = tag.baseZ;
                        });
                        tagGeo.attributes.position.needsUpdate = true;
                        // Rebuild tag node map with final positions
                        this.tagNodeMap = {};
                        this.tagNodes.forEach(t => this.tagNodeMap[t.id] = t);
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            dispose() {
                this.particles.geometry.dispose();
                this.particles.material.dispose();
                if (this.tagPoints) {
                    this.tagPoints.geometry.dispose();
                    this.tagPoints.material.dispose();
                }
                this.hideConnectionLines(); // Clean up connection lines
                this.renderer.dispose();
                if (this.tooltip) {
                    this.tooltip.remove();
                }
            }
        }

        // =====================================================
        // Main Application
        // =====================================================
        marked.setOptions({ breaks: true, gfm: true });

        // State
        let sessionId = null;
        let currentIntent = '';
        let facts = [];
        let conflicts = [];
        let pendingQuestions = [];
        let knowledgeMap = null;

        // DOM
        const startScreen = document.getElementById('start-screen');
        const chatScreen = document.getElementById('chat-screen');
        const startForm = document.getElementById('start-form');
        const chatForm = document.getElementById('chat-form');
        const intentInput = document.getElementById('intent-input');
        const messageInput = document.getElementById('message-input');
        const chatMessages = document.getElementById('chat-messages');
        const factTableEl = document.getElementById('fact-table');
        const factCountEl = document.getElementById('fact-count');
        const factTableWrapper = document.getElementById('fact-table-wrapper');
        const factLedgerToggle = document.getElementById('fact-ledger-toggle');
        const factLedgerArrow = document.getElementById('fact-ledger-arrow');
        const sessionListEl = document.getElementById('session-list');
        const sendBtn = document.getElementById('send-btn');
        const startBtn = document.getElementById('start-btn');
        const startBtnText = document.getElementById('start-btn-text');
        const startBtnSpinner = document.getElementById('start-btn-spinner');
        const newSessionBtn = document.getElementById('new-session-btn');
        const newSessionBtnText = document.getElementById('new-session-btn-text');
        const newSessionBtnSpinner = document.getElementById('new-session-btn-spinner');
        const headerStatus = document.getElementById('header-status');
        const conflictsSection = document.getElementById('conflicts-section');
        const conflictsToggle = document.getElementById('conflicts-toggle');
        const conflictsList = document.getElementById('conflicts-list');
        const conflictsCountBadge = document.getElementById('conflicts-count-badge');
        const questionsSection = document.getElementById('questions-section');
        const questionsToggle = document.getElementById('questions-toggle');
        const questionsList = document.getElementById('questions-list');
        const questionsCountBadge = document.getElementById('questions-count-badge');
        
        // Metrics
        const metricFacts = document.getElementById('metric-facts');
        const metricTags = document.getElementById('metric-tags');
        const metricConflicts = document.getElementById('metric-conflicts');

        const API_BASE = window.location.origin;
        const USER_ID = 'web-user';
        
        let isStarting = false;
        let isSending = false;

        // ==================== Session Loading Overlay ====================
        const sessionLoadingOverlay = document.getElementById('session-loading-overlay');
        const sessionLoadingText = document.getElementById('session-loading-text');

        function showSessionLoading(message = '„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÊ∫ñÂÇô‰∏≠...') {
            sessionLoadingText.textContent = message;
            sessionLoadingOverlay.classList.remove('hidden');
            // Trigger reflow for transition
            requestAnimationFrame(() => {
                sessionLoadingOverlay.classList.remove('opacity-0');
                sessionLoadingOverlay.classList.add('opacity-100');
            });
            // Disable all session-start buttons to prevent double-clicks
            document.querySelectorAll('[data-session-btn]').forEach(btn => {
                btn.disabled = true;
                btn.classList.add('pointer-events-none', 'opacity-50');
            });
        }

        function hideSessionLoading() {
            sessionLoadingOverlay.classList.remove('opacity-100');
            sessionLoadingOverlay.classList.add('opacity-0');
            setTimeout(() => sessionLoadingOverlay.classList.add('hidden'), 300);
            // Re-enable all session-start buttons
            document.querySelectorAll('[data-session-btn]').forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('pointer-events-none', 'opacity-50');
            });
        }

        // ==================== Sidebar Resize & Toggle ====================
        const leftPane = document.getElementById('left-pane');
        const rightPane = document.getElementById('right-pane');
        const resizeHandleLeft = document.getElementById('resize-handle-left');
        const resizeHandleRight = document.getElementById('resize-handle-right');
        const toggleLeftBtn = document.getElementById('toggle-left-pane');
        let leftPaneCollapsed = false;

        // Restore sidebar widths from localStorage
        const savedLeftWidth = localStorage.getItem('el-left-pane-width');
        const savedRightWidth = localStorage.getItem('el-right-pane-width');
        const savedLeftCollapsed = localStorage.getItem('el-left-pane-collapsed');
        if (savedLeftWidth && !savedLeftCollapsed) leftPane.style.width = savedLeftWidth + 'px';
        if (savedRightWidth) rightPane.style.width = savedRightWidth + 'px';
        if (savedLeftCollapsed === 'true') {
            leftPaneCollapsed = true;
            leftPane.classList.add('collapsed');
            resizeHandleLeft.style.display = 'none';
        }

        // Function to get right pane max width based on left pane state
        function getRightPaneMaxWidth() {
            const viewportWidth = window.innerWidth;
            if (leftPaneCollapsed) {
                // Left pane is collapsed, allow up to 80% of viewport width
                return Math.floor(viewportWidth * 0.8);
            } else {
                // Left pane is visible, use fixed max width
                return 600;
            }
        }

        // Generic resize handler factory
        function createResizeHandler(pane, handle, side) {
            let startX, startWidth;

            function onMouseDown(e) {
                e.preventDefault();
                startX = e.clientX;
                startWidth = pane.getBoundingClientRect().width;
                handle.classList.add('dragging');
                pane.style.transition = 'none'; // Disable transition during drag
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            function onMouseMove(e) {
                const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
                let maxWidth;
                if (side === 'right') {
                    maxWidth = getRightPaneMaxWidth();
                } else {
                    maxWidth = parseInt(pane.style.maxWidth) || 600;
                }
                const newWidth = Math.max(
                    parseInt(pane.style.minWidth) || 180,
                    Math.min(maxWidth, startWidth + delta)
                );
                pane.style.width = newWidth + 'px';
                // Keep knowledge map centered during drag
                if (knowledgeMap) knowledgeMap.handleResize();
            }

            function onMouseUp() {
                handle.classList.remove('dragging');
                pane.style.transition = ''; // Re-enable transition
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                // Persist width
                const key = side === 'left' ? 'el-left-pane-width' : 'el-right-pane-width';
                localStorage.setItem(key, Math.round(pane.getBoundingClientRect().width));
                // Resize knowledge map if right pane changed
                if (side === 'right' && knowledgeMap) {
                    knowledgeMap.resize?.();
                }
            }

            handle.addEventListener('mousedown', onMouseDown);
        }

        createResizeHandler(leftPane, resizeHandleLeft, 'left');
        createResizeHandler(rightPane, resizeHandleRight, 'right');

        // Left pane toggle
        toggleLeftBtn.addEventListener('click', () => {
            leftPaneCollapsed = !leftPaneCollapsed;
            if (leftPaneCollapsed) {
                leftPane.classList.add('collapsed');
                resizeHandleLeft.style.display = 'none';
                localStorage.setItem('el-left-pane-collapsed', 'true');
                // Update right pane max width when left pane is collapsed
                const currentRightWidth = rightPane.getBoundingClientRect().width;
                const maxRightWidth = getRightPaneMaxWidth();
                if (currentRightWidth > maxRightWidth) {
                    rightPane.style.width = maxRightWidth + 'px';
                    localStorage.setItem('el-right-pane-width', maxRightWidth);
                }
            } else {
                leftPane.classList.remove('collapsed');
                leftPane.style.width = (savedLeftWidth || 260) + 'px';
                resizeHandleLeft.style.display = '';
                localStorage.removeItem('el-left-pane-collapsed');
                // Restore right pane max width when left pane is expanded
                const currentRightWidth = rightPane.getBoundingClientRect().width;
                const maxRightWidth = getRightPaneMaxWidth();
                if (currentRightWidth > maxRightWidth) {
                    rightPane.style.width = maxRightWidth + 'px';
                    localStorage.setItem('el-right-pane-width', maxRightWidth);
                }
            }
        });

        // Update right pane max width on window resize
        window.addEventListener('resize', () => {
            if (leftPaneCollapsed) {
                const currentRightWidth = rightPane.getBoundingClientRect().width;
                const maxRightWidth = getRightPaneMaxWidth();
                if (currentRightWidth > maxRightWidth) {
                    rightPane.style.width = maxRightWidth + 'px';
                    localStorage.setItem('el-right-pane-width', maxRightWidth);
                }
            }
        });

        // Initialize Knowledge Map
        let knowledgeMapModal = null; // Separate KnowledgeMap instance for modal
        requestAnimationFrame(() => {
            const mapContainer = document.getElementById('knowledge-map-canvas');
            if (mapContainer) {
                knowledgeMap = new KnowledgeMap(mapContainer);
            }
        });

        // Knowledge Map Modal
        const kmModal = document.getElementById('knowledge-map-modal');
        const kmModalBackdrop = document.getElementById('km-modal-backdrop');
        const kmModalClose = document.getElementById('km-modal-close');
        const kmModalCanvas = document.getElementById('km-modal-canvas');

        function openKnowledgeMapModal() {
            // Sync metrics
            document.getElementById('km-modal-facts').textContent = document.getElementById('metric-facts').textContent;
            document.getElementById('km-modal-tags').textContent = document.getElementById('metric-tags').textContent;
            document.getElementById('km-modal-conflicts').textContent = document.getElementById('metric-conflicts').textContent;

            // Show modal
            kmModal.classList.remove('hidden');
            // Force reflow then add visible class for animation
            kmModal.offsetHeight;
            kmModal.classList.add('visible');

            // Create a dedicated KnowledgeMap for the modal (larger, higher quality)
            requestAnimationFrame(() => {
                if (knowledgeMapModal) {
                    knowledgeMapModal.dispose();
                    kmModalCanvas.innerHTML = '';
                }
                knowledgeMapModal = new KnowledgeMap(kmModalCanvas);
                // Copy rotation state from sidebar map
                if (knowledgeMap) {
                    knowledgeMapModal.targetRotationX = knowledgeMap.targetRotationX;
                    knowledgeMapModal.targetRotationY = knowledgeMap.targetRotationY;
                    knowledgeMapModal.targetZoom = knowledgeMap.radius * 2.5;
                    knowledgeMapModal.particles.rotation.x = knowledgeMap.particles.rotation.x;
                    knowledgeMapModal.particles.rotation.y = knowledgeMap.particles.rotation.y;
                }
            });

            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        function closeKnowledgeMapModal() {
            kmModal.classList.remove('visible');
            // Wait for animation to finish, then hide
            setTimeout(() => {
                kmModal.classList.add('hidden');
                // Dispose modal map instance
                if (knowledgeMapModal) {
                    knowledgeMapModal.dispose();
                    knowledgeMapModal = null;
                    kmModalCanvas.innerHTML = '';
                }
                document.body.style.overflow = '';
            }, 250);
        }

        document.getElementById('map-detail-btn').addEventListener('click', openKnowledgeMapModal);
        kmModalClose.addEventListener('click', closeKnowledgeMapModal);
        kmModalBackdrop.addEventListener('click', closeKnowledgeMapModal);
        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !kmModal.classList.contains('hidden')) {
                closeKnowledgeMapModal();
            }
        });

        // Domain config (simplified)
        const domainConfig = {
            'daily_work': { emoji: 'üíº', label: 'Ê•≠ÂãôÂ†±Âëä' },
            'recipe': { emoji: 'üç≥', label: '„É¨„Ç∑„Éî' },
            'postmortem': { emoji: 'üîç', label: 'ÊåØ„ÇäËøî„Çä' },
            'creative': { emoji: 'üé®', label: 'Ââµ‰Ωú' },
            'general': { emoji: 'üí≠', label: '‰∏ÄËà¨' }
        };

        // Auto-resize textarea
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 160) + 'px';
        });

        // Enter to send
        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey && !e.isComposing) {
                e.preventDefault();
                chatForm.dispatchEvent(new Event('submit'));
            }
        });

        // Load recent sessions
        async function loadSessions() {
            try {
                const res = await fetch(`${API_BASE}/api/users/${USER_ID}/sessions?limit=10`);
                if (!res.ok) return;
                const sessions = await res.json();
                renderSessionList(sessions);
            } catch (e) {
                console.error('Error loading sessions:', e);
            }
        }

        function renderSessionList(sessions) {
            if (!sessions || sessions.length === 0) {
                sessionListEl.innerHTML = '<p class="text-xs text-slate-600 py-4 text-center">Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                return;
            }
            
            sessionListEl.innerHTML = sessions.map(s => {
                const config = domainConfig[s.domain] || domainConfig['general'];
                const status = s.has_conflicts ? 'conflict' : (s.verified_count > 0 ? 'verified' : 'draft');
                return `
                    <div class="session-item p-2.5 rounded-lg hover:bg-surface-2 cursor-pointer transition-colors" data-id="${s.id}" data-session-btn>
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-xs">${config.emoji}</span>
                            <span class="text-sm text-white truncate flex-1">${escapeHtml(s.topic)}</span>
                            <span class="w-1.5 h-1.5 rounded-full ${status === 'conflict' ? 'bg-conflict' : status === 'verified' ? 'bg-verified' : 'bg-pending'}"></span>
                        </div>
                        <div class="text-[10px] text-slate-500">${formatTimeAgo(s.updated_at)} ¬∑ ${s.turn_count || 0}„Çø„Éº„É≥</div>
                    </div>
                `;
            }).join('');
            
            // Click handlers
            sessionListEl.querySelectorAll('.session-item').forEach(el => {
                el.addEventListener('click', () => resumeSession(el.dataset.id));
            });
        }

        function formatTimeAgo(iso) {
            if (!iso) return '';
            // „Çµ„Éº„Éê„Éº„Åã„Çâ„ÅÆÊôÇÂàª„ÅØUTC„Å™„ÅÆ„Åß„ÄÅZ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØËøΩÂä†
            const isoUtc = iso.endsWith('Z') ? iso : iso + 'Z';
            const d = new Date(isoUtc);
            const now = new Date();
            const diff = Math.floor((now - d) / 60000);
            if (diff < 1) return '„Åü„Å£„Åü‰ªä';
            if (diff < 60) return `${diff}ÂàÜÂâç`;
            if (diff < 1440) return `${Math.floor(diff / 60)}ÊôÇÈñìÂâç`;
            return `${Math.floor(diff / 1440)}Êó•Ââç`;
        }

        // Start session
        startForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const intent = intentInput.value.trim();
            if (!intent || isStarting) return;
            
            isStarting = true;
            startBtn.disabled = true;
            startBtnText.textContent = 'ÈñãÂßã‰∏≠...';
            startBtnSpinner.classList.remove('hidden');
            showSessionLoading('„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßã‰∏≠...');
            
            try {
                const res = await fetch(`${API_BASE}/api/sessions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic: intent, user_id: USER_ID })
                });
                
                if (!res.ok) throw new Error('Failed to start session');
                
                const data = await res.json();
                sessionId = data.session_id;
                currentIntent = intent;
                
                // Update UI
                startScreen.classList.add('hidden');
                chatScreen.classList.remove('hidden');
                
                // Show user's initial input as the first message in chat
                addMessage(intent, 'user');
                addMessage(data.opening_message, 'assistant');
                messageInput.focus();
                updateStatus('Collecting');
                
                if (data.prior_knowledge_count > 0) {
                    showToast(`${data.prior_knowledge_count}‰ª∂„ÅÆÈÅéÂéª„ÅÆË®òÈå≤„ÇíÁô∫Ë¶ã`, 'info');
                    if (knowledgeMap) knowledgeMap.onFactVerified(data.prior_knowledge_count);
                }
                
            } catch (err) {
                console.error('Error starting session:', err);
                showToast('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                isStarting = false;
                startBtn.disabled = false;
                startBtnText.textContent = 'ÈñãÂßã';
                startBtnSpinner.classList.add('hidden');
                hideSessionLoading();
            }
        });

        // Resume session
        async function resumeSession(id) {
            if (isStarting) return;
            isStarting = true;
            showSessionLoading('„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíË™≠„ÅøËæº„Åø‰∏≠...');
            
            try {
                const res = await fetch(`${API_BASE}/api/sessions/${id}/resume`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: USER_ID })
                });
                
                if (!res.ok) throw new Error('Failed to resume');
                
                const data = await res.json();
                sessionId = data.session_id;
                currentIntent = data.topic;
                
                startScreen.classList.add('hidden');
                chatScreen.classList.remove('hidden');
                
                // Clear existing messages
                chatMessages.innerHTML = '';
                
                // Restore conversation history
                if (data.conversation_history?.length > 0) {
                    data.conversation_history.forEach(msg => {
                        addMessage(msg.content, msg.role);
                    });
                    showToast(`üìú ${data.conversation_history.length / 2}„Çø„Éº„É≥„ÅÆ‰ºöË©±„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü`, 'info');
                }
                
                // Show resume message if no history
                if (!data.conversation_history?.length && data.resume_message) {
                    addMessage(data.resume_message, 'assistant');
                }
                
                messageInput.focus();
                updateStatus('Collecting');
                
                // Load prior insights
                if (data.prior_insights?.length > 0) {
                    data.prior_insights.forEach(insight => addFact(insight));
                    updateMetrics();
                }
                
                // Load pending questions for this session
                loadPendingQuestions(sessionId);
                
            } catch (err) {
                console.error('Error resuming session:', err);
                showToast('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÂÜçÈñã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                isStarting = false;
                hideSessionLoading();
            }
        }

        async function loadPendingQuestions(sid) {
            try {
                const res = await fetch(`${API_BASE}/api/sessions/${sid}/questions?status=pending`);
                if (!res.ok) return;
                const data = await res.json();
                
                pendingQuestions = data.questions || [];
                renderPendingQuestions();
                
                if (pendingQuestions.length > 0) {
                    showToast(`Êú™ÂõûÁ≠î„ÅÆË≥™Âïè„Åå${pendingQuestions.length}‰ª∂„ÅÇ„Çä„Åæ„Åô`, 'info');
                }
            } catch (e) {
                console.error('Error loading pending questions:', e);
            }
        }

        // Send message
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const msg = messageInput.value.trim();
            if (!msg || !sessionId || isSending) return;
            
            isSending = true;
            addMessage(msg, 'user');
            messageInput.value = '';
            messageInput.style.height = 'auto';
            sendBtn.disabled = true;
            updateStatus('Âá¶ÁêÜ‰∏≠...');
            
            const typingId = showTyping();
            
            try {
                const res = await fetch(`${API_BASE}/api/sessions/${sessionId}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: msg })
                });
                
                if (!res.ok) throw new Error('API Error');
                
                const data = await res.json();
                removeTyping(typingId);
                
                addMessage(data.response, 'assistant', data.knowledge_detail || []);
                
                // Handle insights
                if (data.insights_saved > 0 && data.insights_detail) {
                    data.insights_detail.forEach(i => addFact(i));
                    if (knowledgeMap) knowledgeMap.onFactVerified(data.insights_saved);
                    showToast(`${data.insights_saved}‰ª∂„ÅÆ‰∫ãÂÆü„ÇíË®òÈå≤`, 'success');
                }
                
                // Handle conflicts
                if (data.consistency_issues?.length > 0) {
                    data.consistency_issues.forEach(c => addConflict(c));
                    if (knowledgeMap) knowledgeMap.onConflict();
                }
                
                // Handle pending questions
                if (data.pending_questions?.length > 0) {
                    data.pending_questions.forEach(q => addPendingQuestion(q));
                }
                
                // Handle answered questions - remove from pending
                if (data.questions_answered?.length > 0) {
                    data.questions_answered.forEach(qid => markQuestionAnswered(qid));
                    showToast(`${data.questions_answered.length}‰ª∂„ÅÆË≥™Âïè„Å´ÂõûÁ≠î„Åó„Åæ„Åó„Åü`, 'success');
                }
                
                // Handle aggregation suggestion
                if (data.aggregation_suggestion) {
                    showAggregationSuggestion(data.aggregation_suggestion);
                }
                
                // Handle suggested questions
                if (data.suggested_questions?.length > 0) {
                    document.getElementById('next-question-hint').textContent = 
                        'üí° ' + data.suggested_questions[0];
                }
                
                updateMetrics();
                loadKnowledgeStats(); // Update stats after each message
                updateStatus('Collecting');
                
                // Show in-chat notice if documents are pending review
                showDocumentReviewNoticeInChat();
                
            } catch (err) {
                console.error('Error sending message:', err);
                removeTyping(typingId);
                showToast('ÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                isSending = false;
                sendBtn.disabled = false;
                messageInput.focus();
            }
        });

        // New session button (replaces end session button)
        newSessionBtn.addEventListener('click', async () => {
            // Prevent multiple clicks
            if (newSessionBtn.disabled) return;
            
            // If there's an active session, end it first
            if (sessionId) {
                if (!confirm('„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁµÇ‰∫Ü„Åó„Å¶Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈñãÂßã„Åó„Åæ„Åô„ÅãÔºü')) return;
                
                newSessionBtn.disabled = true;
                newSessionBtnText.textContent = 'ÁµÇ‰∫Ü‰∏≠...';
                newSessionBtnSpinner.classList.remove('hidden');
                updateStatus('Ë¶ÅÁ¥ÑÁîüÊàê‰∏≠...');
                
                try {
                    const res = await fetch(`${API_BASE}/api/sessions/${sessionId}/end`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (res.ok) {
                        const data = await res.json();
                        if (data.summary) showSummaryModal(data.summary);
                    }
                    
                } catch (err) {
                    console.error('Error ending session:', err);
                } finally {
                    newSessionBtn.disabled = false;
                    newSessionBtnText.textContent = '+ Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥';
                    newSessionBtnSpinner.classList.add('hidden');
                }
            }
            
            resetSession();
        });

        // Fact Ledger toggle
        factLedgerToggle?.addEventListener('click', () => {
            const isHidden = factTableWrapper.classList.toggle('hidden');
            factLedgerArrow.textContent = isHidden ? '‚ñ∂' : '‚ñº';
            factLedgerArrow.style.transform = ''; // reset any transform
        });

        // Conflicts toggle
        conflictsToggle?.addEventListener('click', () => {
            conflictsList.classList.toggle('hidden');
        });

        questionsToggle?.addEventListener('click', () => {
            questionsList.classList.toggle('hidden');
        });

        // Helper functions
        function addMessage(text, type, knowledgeDetail = []) {
            const div = document.createElement('div');
            div.className = `fade-up flex ${type === 'user' ? 'justify-end' : 'justify-start'}`;
            
            // Container for bubble + reference section
            const container = document.createElement('div');
            container.className = 'max-w-[75%]';
            
            const bubble = document.createElement('div');
            bubble.className = type === 'user' 
                ? 'px-4 py-2.5 rounded-2xl bg-accent text-surface-0 text-sm'
                : 'px-4 py-2.5 rounded-2xl bg-surface-3 text-slate-200 text-sm prose-msg';
            
            if (type === 'user') {
                bubble.textContent = text;
            } else {
                bubble.innerHTML = marked.parse(text);
            }
            
            container.appendChild(bubble);
            
            // Add expandable referenced facts section for assistant messages with knowledge
            if (type === 'assistant' && knowledgeDetail && knowledgeDetail.length > 0) {
                const refId = 'ref-' + Date.now();
                const refSection = document.createElement('div');
                refSection.className = 'mt-2 ml-1';
                refSection.innerHTML = `
                    <button 
                        class="text-[10px] text-blue-400 hover:text-blue-300 flex items-center gap-1 transition-colors"
                        onclick="document.getElementById('${refId}').classList.toggle('hidden'); this.querySelector('.ref-arrow').textContent = document.getElementById('${refId}').classList.contains('hidden') ? '‚ñ∂' : '‚ñº';"
                    >
                        <span class="ref-arrow">‚ñ∂</span>
                        <span>üìö ÂèÇÁÖß„Åó„Åü‰∫ãÂÆü (${knowledgeDetail.length}‰ª∂)</span>
                    </button>
                    <div id="${refId}" class="hidden mt-2 space-y-1.5 pl-2 border-l-2 border-blue-400/30">
                        ${knowledgeDetail.map(k => {
                            const subject = escapeHtml(k.subject || '');
                            const predicate = escapeHtml(k.predicate || '');
                            const object = escapeHtml(k.object || '');
                            const domain = k.domain || 'general';
                            const date = k.created_at ? new Date(k.created_at).toLocaleDateString('ja-JP') : '';
                            
                            return `
                                <div class="bg-surface-2/50 rounded-lg p-2 text-[10px]">
                                    <div class="flex items-start gap-1.5">
                                        <span class="text-blue-400 flex-none mt-0.5">‚Ä¢</span>
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center gap-1 flex-wrap">
                                                <span class="text-slate-400 font-medium">${subject}</span>
                                                <span class="text-slate-500">‚Üí</span>
                                                <span class="text-slate-300">${predicate}</span>
                                            </div>
                                            <div class="text-white mt-0.5">${object}</div>
                                            ${date ? `<div class="text-slate-600 mt-1 text-[9px]">${date}</div>` : ''}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                container.appendChild(refSection);
            }
            
            div.appendChild(container);
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTyping() {
            const id = 'typing-' + Date.now();
            const div = document.createElement('div');
            div.id = id;
            div.className = 'flex justify-start fade-up';
            div.innerHTML = `
                <div class="px-4 py-3 rounded-2xl bg-surface-3">
                    <div class="flex gap-1">
                        <span class="typing-dot w-1.5 h-1.5 bg-slate-400 rounded-full"></span>
                        <span class="typing-dot w-1.5 h-1.5 bg-slate-400 rounded-full"></span>
                        <span class="typing-dot w-1.5 h-1.5 bg-slate-400 rounded-full"></span>
                    </div>
                </div>
            `;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return id;
        }

        function removeTyping(id) {
            document.getElementById(id)?.remove();
        }

        function addFact(fact) {
            // Avoid duplicates by id
            if (fact.id && facts.some(f => f.id === fact.id)) return;
            facts.push(fact);
            renderFacts();
        }

        // Load all facts from the knowledge graph (documents + sessions)
        async function loadAllFacts() {
            try {
                const res = await fetch(`${API_BASE}/api/facts/recent?limit=50`);
                if (!res.ok) return;
                const data = await res.json();
                
                if (data.facts?.length > 0) {
                    // Merge with existing session facts (avoid duplicates)
                    const existingIds = new Set(facts.map(f => f.id).filter(Boolean));
                    for (const fact of data.facts) {
                        if (!existingIds.has(fact.id)) {
                            facts.push(fact);
                            existingIds.add(fact.id);
                        }
                    }
                    renderFacts();
                    updateMetrics();
                }
            } catch (e) {
                console.error('Error loading all facts:', e);
            }
        }

        function renderFacts() {
            if (facts.length === 0) {
                factTableEl.innerHTML = '<p class="text-xs text-slate-600 py-4 text-center">„Åæ„Å†Ë®òÈå≤„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                factCountEl.textContent = '0 facts';
                return;
            }
            
            factCountEl.textContent = `${facts.length} facts`;
            // Auto-expand when facts are loaded
            if (factTableWrapper && factTableWrapper.classList.contains('hidden')) {
                factTableWrapper.classList.remove('hidden');
                if (factLedgerArrow) factLedgerArrow.textContent = '‚ñº';
            }
            factTableEl.innerHTML = facts.map((f, i) => {
                const status = f.verified ? 'verified' : 'pending';
                const sourceLabel = f.document_filename 
                    ? `<span class="text-[10px] text-purple-400/60">üìÑ ${escapeHtml(f.document_filename)}</span>` 
                    : '';
                return `
                    <div class="fact-row p-2 rounded-lg border border-white/5">
                        <div class="flex items-start gap-2">
                            <span class="w-1.5 h-1.5 mt-1.5 rounded-full flex-none ${status === 'verified' ? 'bg-verified' : 'bg-pending'}"></span>
                            <div class="flex-1 min-w-0">
                                <p class="text-xs text-white leading-relaxed">${escapeHtml(f.predicate ? (f.subject + ' ' + f.predicate + ' ' + (f.object || '')) : (f.object || f.content || ''))}</p>
                                <div class="flex items-center gap-2 mt-1 flex-wrap">
                                    <span class="text-[10px] text-slate-500">${escapeHtml(f.subject || '')}</span>
                                    ${sourceLabel}
                                    ${f.tags?.length > 0 ? f.tags.map(t => `<span class="text-[10px] bg-surface-3 px-1.5 py-0.5 rounded">${escapeHtml(t)}</span>`).join('') : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addConflict(conflict) {
            // Only add if not already present (by id)
            if (conflict.id && conflicts.some(c => c.id === conflict.id)) {
                return;
            }
            conflicts.push(conflict);
            renderConflicts();
        }

        // Load conflicts from API
        async function loadConflicts() {
            try {
                const res = await fetch(`${API_BASE}/api/conflicts?include_resolved=false`);
                if (!res.ok) return;
                const data = await res.json();
                
                // Replace current conflicts with persisted ones
                conflicts = data.conflicts || [];
                renderConflicts();
                updateMetrics();
            } catch (e) {
                console.error('Error loading conflicts:', e);
            }
        }

        function renderConflicts() {
            // Filter to show only unresolved conflicts
            const unresolvedConflicts = conflicts.filter(c => 
                !c.status || c.status === 'unresolved'
            );
            
            if (unresolvedConflicts.length === 0) {
                conflictsSection.classList.add('hidden');
                conflictsCountBadge.textContent = '0';
                updateMetrics();
                return;
            }
            
            conflictsSection.classList.remove('hidden');
            conflictsCountBadge.textContent = unresolvedConflicts.length;
            updateMetrics();
            
            conflictsList.innerHTML = unresolvedConflicts.map((c) => {
                // Handle both snake_case (API) and camelCase field names
                const conflictId = c.id || '';
                const prevText = c.previous_text || c.previousText || c.previous?.text || c.previous || '(‰∏çÊòé)';
                const currText = c.current_text || c.currentText || c.current?.text || c.current || '(‰∏çÊòé)';
                const prevSource = c.previous_source || c.previousSource || '';
                const title = c.title || c.subject || 'ÊÉÖÂ†±„ÅÆÂ§âÊõ¥';
                const kind = c.kind || 'change';
                const kindLabel = kind === 'contradiction' ? 'ÁüõÁõæ' : 'Â§âÊõ¥';
                const kindColor = kind === 'contradiction' ? 'text-conflict' : 'text-amber-400';
                const kindBorderColor = kind === 'contradiction' ? 'border-conflict/30' : 'border-amber-400/20';
                const suggestedQ = c.suggested_question || c.suggestedQuestion || '';
                const explanation = c.explanation || '';
                
                return `
                    <div class="bg-surface-2 border ${kindBorderColor} rounded-lg overflow-hidden" data-conflict-id="${escapeHtml(conflictId)}">
                        <div class="px-3 py-2 border-b border-white/5 flex items-center gap-2">
                            <span class="text-[10px] ${kindColor} bg-white/5 px-1.5 py-0.5 rounded font-medium">${kindLabel}</span>
                            <span class="text-xs text-white font-medium flex-1">${escapeHtml(title)}</span>
                            ${prevSource ? `<span class="text-[9px] text-slate-600">${escapeHtml(prevSource)}</span>` : ''}
                        </div>
                        ${explanation ? `
                        <div class="px-3 py-2 bg-white/[0.02] border-b border-white/5">
                            <p class="text-[11px] text-slate-300 leading-relaxed">${escapeHtml(explanation)}</p>
                        </div>
                        ` : ''}
                        <div class="px-3 py-2 space-y-1.5">
                            <div class="text-[11px] bg-surface-3/50 rounded px-2 py-1.5">
                                <span class="text-slate-500 font-medium">‰ª•Ââç:</span>
                                <span class="text-slate-300 ml-1">${escapeHtml(prevText)}</span>
                            </div>
                            <div class="text-[11px] bg-surface-3/50 rounded px-2 py-1.5">
                                <span class="text-slate-500 font-medium">‰ªäÂõû:</span>
                                <span class="text-white ml-1">${escapeHtml(currText)}</span>
                            </div>
                        </div>
                        ${suggestedQ ? `
                        <div class="px-3 py-2 border-t border-white/5">
                            <p class="text-[11px] text-blue-400/80 italic leading-relaxed">üí° ${escapeHtml(suggestedQ)}</p>
                        </div>
                        ` : ''}
                        <div class="flex border-t border-white/5">
                            <button class="flex-1 py-2 text-center text-verified text-[10px] font-medium hover:bg-verified/10 transition-colors border-r border-white/5" 
                                onclick="resolveConflict('${escapeHtml(conflictId)}', 'accept_current')">
                                ‚úì ‰ªäÂõû„ÇíÊé°Áî®
                            </button>
                            <button class="flex-1 py-2 text-center text-amber-400 text-[10px] font-medium hover:bg-amber-500/10 transition-colors border-r border-white/5" 
                                onclick="resolveConflict('${escapeHtml(conflictId)}', 'keep_previous')">
                                ‚Ü© ‰ª•Ââç„ÇíÁ∂≠ÊåÅ
                            </button>
                            <button class="flex-1 py-2 text-center text-slate-500 text-[10px] hover:bg-white/5 transition-colors" 
                                onclick="resolveConflict('${escapeHtml(conflictId)}', 'ignore')">
                                ÁÑ°Ë¶ñ
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        window.resolveConflict = async function(conflictId, resolution) {
            if (!conflictId) {
                // Fallback for old-style conflicts without ID (just remove from local state)
                showToast('„Åì„ÅÆÁüõÁõæ„ÅØËß£Ê±∫„Åß„Åç„Åæ„Åõ„Çì', 'error');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/conflicts/${conflictId}/resolve`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ resolution: resolution })
                });
                
                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.detail || 'Failed to resolve conflict');
                }
                
                // Remove from local state
                conflicts = conflicts.filter(c => c.id !== conflictId);
                renderConflicts();
                updateMetrics();
                
                // Show appropriate message
                const messages = {
                    'accept_current': '‰ªäÂõû„ÅÆÂÜÖÂÆπ„ÇíÊé°Áî®„Åó„Åæ„Åó„Åü',
                    'keep_previous': '‰ª•Ââç„ÅÆÂÜÖÂÆπ„ÇíÁ∂≠ÊåÅ„Åó„Åæ„Åô',
                    'ignore': '„Åì„ÅÆÁüõÁõæ„ÇíÁÑ°Ë¶ñ„Åó„Åæ„Åó„Åü'
                };
                showToast(messages[resolution] || 'Ëß£Ê±∫„Åó„Åæ„Åó„Åü', 'success');
                
            } catch (e) {
                console.error('Error resolving conflict:', e);
                showToast('ÁüõÁõæ„ÅÆËß£Ê±∫„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e.message, 'error');
            }
        };

        // ==================== Pending Questions ====================

        function addPendingQuestion(question) {
            // Only add if not already present (by id) and status is pending
            if (question.id && pendingQuestions.some(q => q.id === question.id)) {
                return;
            }
            if (question.status && question.status !== 'pending') {
                return;
            }
            pendingQuestions.push(question);
            renderPendingQuestions();
        }

        function markQuestionAnswered(questionId) {
            const idx = pendingQuestions.findIndex(q => q.id === questionId);
            if (idx !== -1) {
                pendingQuestions[idx].status = 'answered';
            }
            renderPendingQuestions();
        }

        function renderPendingQuestions() {
            const pending = pendingQuestions.filter(q => q.status === 'pending');

            if (pending.length === 0) {
                questionsSection.classList.add('hidden');
                questionsCountBadge.textContent = '0';
                return;
            }

            questionsSection.classList.remove('hidden');
            questionsCountBadge.textContent = pending.length;

            questionsList.innerHTML = pending.map((q) => {
                const kindLabels = {
                    'contradiction': 'ÁüõÁõæ',
                    'change': 'Â§âÊõ¥',
                    'missing': '‰∏çË∂≥',
                    'clarification': 'Á¢∫Ë™ç'
                };
                const kindColors = {
                    'contradiction': 'text-conflict',
                    'change': 'text-amber-400',
                    'missing': 'text-blue-400',
                    'clarification': 'text-purple-400'
                };
                const kind = q.kind || 'missing';
                const kindLabel = kindLabels[kind] || 'Ë≥™Âïè';
                const kindColor = kindColors[kind] || 'text-blue-400';
                const questionId = q.id || '';
                const questionText = q.question || '';
                const context = q.context || '';
                const priority = q.priority || 0;

                return `
                    <div class="bg-blue-500/5 border border-blue-500/20 rounded-lg p-3" data-question-id="${escapeHtml(questionId)}">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-[10px] ${kindColor} bg-white/5 px-1.5 py-0.5 rounded">${kindLabel}</span>
                            ${priority >= 7 ? '<span class="text-[10px] text-amber-400">&#9733;</span>' : ''}
                            <span class="text-[10px] text-slate-500 ml-auto">P${priority}</span>
                        </div>
                        <div class="text-xs text-white mb-1">${escapeHtml(questionText)}</div>
                        ${context ? `
                        <div class="text-[10px] text-slate-400 mb-2">${escapeHtml(context)}</div>
                        ` : ''}
                        <div id="question-actions-${escapeHtml(questionId)}" class="flex flex-col gap-1.5">
                            <div id="question-answer-form-${escapeHtml(questionId)}" class="hidden">
                                <textarea class="w-full bg-surface-2 border border-white/10 rounded text-xs text-white p-2 resize-none focus:border-blue-400/50 focus:outline-none placeholder-slate-500"
                                    rows="2"
                                    placeholder="ÂõûÁ≠î„ÇíÂÖ•Âäõ..."
                                    id="question-answer-input-${escapeHtml(questionId)}"></textarea>
                                <div class="flex gap-1 mt-1">
                                    <button class="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-[10px] rounded hover:bg-emerald-500/30"
                                        onclick="submitAnswer('${escapeHtml(questionId).replace(/'/g, "\\'")}', '${escapeHtml(questionText).replace(/'/g, "\\'")}')">
                                        ÈÄÅ‰ø°
                                    </button>
                                    <button class="px-2 py-1 bg-surface-3 text-slate-400 text-[10px] rounded hover:bg-surface-4"
                                        onclick="cancelAnswer('${escapeHtml(questionId).replace(/'/g, "\\'")}')">
                                        „Ç≠„É£„É≥„Çª„É´
                                    </button>
                                </div>
                            </div>
                            <div id="question-buttons-${escapeHtml(questionId)}" class="flex gap-1">
                                <button class="px-2 py-1 bg-emerald-500/20 text-emerald-400 text-[10px] rounded hover:bg-emerald-500/30"
                                    onclick="showAnswerForm('${escapeHtml(questionId).replace(/'/g, "\\'")}')">
                                    &#x270D; ÂõûÁ≠î„Åô„Çã
                                </button>
                                <button class="px-2 py-1 bg-surface-3 text-slate-400 text-[10px] rounded hover:bg-surface-4"
                                    onclick="skipQuestion('${escapeHtml(questionId)}')">
                                    „Çπ„Ç≠„ÉÉ„Éó
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        window.showAnswerForm = function(questionId) {
            const form = document.getElementById(`question-answer-form-${questionId}`);
            const buttons = document.getElementById(`question-buttons-${questionId}`);
            if (form) form.classList.remove('hidden');
            if (buttons) buttons.classList.add('hidden');
            const input = document.getElementById(`question-answer-input-${questionId}`);
            if (input) input.focus();
        };

        window.cancelAnswer = function(questionId) {
            const form = document.getElementById(`question-answer-form-${questionId}`);
            const buttons = document.getElementById(`question-buttons-${questionId}`);
            if (form) form.classList.add('hidden');
            if (buttons) buttons.classList.remove('hidden');
            const input = document.getElementById(`question-answer-input-${questionId}`);
            if (input) input.value = '';
        };

        window.submitAnswer = async function(questionId, questionText) {
            const input = document.getElementById(`question-answer-input-${questionId}`);
            if (!input) return;
            const answer = input.value.trim();
            if (!answer) {
                showToast('ÂõûÁ≠î„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'warning');
                return;
            }

            // Build contextual message: include the question being answered
            const contextMessage = `„ÄêË≥™Âïè„Å∏„ÅÆÂõûÁ≠î„Äë${questionText}\n‚Üí ${answer}`;

            // Send as a chat message so the agent can process it naturally
            messageInput.value = contextMessage;
            chatForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));

            // Clean up the answer form
            input.value = '';
            cancelAnswer(questionId);
        };

        window.skipQuestion = async function(questionId) {
            if (!questionId || !sessionId) return;

            try {
                const res = await fetch(`${API_BASE}/api/sessions/${sessionId}/questions/${questionId}/skip`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                });

                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.detail || 'Failed to skip question');
                }

                // Update local state
                const idx = pendingQuestions.findIndex(q => q.id === questionId);
                if (idx !== -1) {
                    pendingQuestions[idx].status = 'skipped';
                }
                renderPendingQuestions();
                showToast('Ë≥™Âïè„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü', 'info');

            } catch (e) {
                console.error('Error skipping question:', e);
                showToast('Ë≥™Âïè„ÅÆ„Çπ„Ç≠„ÉÉ„Éó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };

        function updateMetrics() {
            // Facts count
            metricFacts.textContent = facts.length;
            
            // Tags count
            const tagCount = (typeof tagsData !== 'undefined' && Array.isArray(tagsData)) ? tagsData.length : 0;
            metricTags.textContent = tagCount;
            
            // Unresolved conflicts count
            const unresolvedCount = conflicts.filter(c => !c.status || c.status === 'unresolved').length;
            metricConflicts.textContent = unresolvedCount;
        }

        function updateStatus(text) {
            headerStatus.textContent = text;
        }

        function showToast(msg, type = 'info') {
            const toast = document.createElement('div');
            const bg = type === 'success' ? 'bg-verified' : type === 'error' ? 'bg-conflict' : 'bg-surface-3';
            toast.className = `fade-up px-4 py-2.5 ${bg} text-white text-sm rounded-lg shadow-lg pointer-events-auto`;
            toast.textContent = msg;
            document.getElementById('toast-container').appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-10px)';
                toast.style.transition = 'all 0.2s';
                setTimeout(() => toast.remove(), 200);
            }, 3000);
        }

        function showSummaryModal(summary) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-md w-full border border-white/5">
                    <h2 class="text-lg font-semibold text-white mb-4">üìã „Çª„ÉÉ„Ç∑„Éß„É≥Ë¶ÅÁ¥Ñ</h2>
                    <p class="text-sm text-slate-300 mb-4">${escapeHtml(summary.content || '')}</p>
                    ${summary.key_points?.length > 0 ? `
                        <div class="mb-4">
                            <h3 class="text-xs text-slate-400 mb-2">ÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà</h3>
                            <ul class="text-sm text-slate-300 space-y-1">
                                ${summary.key_points.map(p => `<li>‚Ä¢ ${escapeHtml(p)}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    <button class="w-full py-2 bg-accent text-surface-0 rounded-lg font-medium" onclick="this.closest('.fixed').remove()">Èñâ„Åò„Çã</button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
        }

        // =====================================================
        // Document Review (Hybrid approach: non-intrusive)
        // =====================================================

        // Start document review session (called from sidebar badge or start screen banner)
        async function startDocumentReview(docId, filename) {
            if (isStarting) return;

            // If already in a session, ask for confirmation
            if (sessionId) {
                if (!confirm(`ÁèæÂú®„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁµÇ‰∫Ü„Åó„Å¶„Äå${filename}„Äç„ÅÆ„É¨„Éì„É•„Éº„ÇíÈñãÂßã„Åó„Åæ„Åô„ÅãÔºü`)) return;
                try {
                    await fetch(`${API_BASE}/api/sessions/${sessionId}/end`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                } catch (e) {
                    console.error('Error ending session:', e);
                }
                resetSession();
            }

            // Check if there's an existing active review session for this document
            const existingDoc = uploadedDocuments.find(d => d.id === docId);
            if (existingDoc && existingDoc.review_session_id) {
                // Resume existing review session instead of creating a new one
                _pendingReviewDocs = _pendingReviewDocs.filter(d => d.id !== docId);
                renderPendingReviewBanner();
                await resumeSession(existingDoc.review_session_id);
                return;
            }

            isStarting = true;
            showSessionLoading(`„Äå${filename}„Äç„ÅÆ„É¨„Éì„É•„Éº„ÇíÊ∫ñÂÇô‰∏≠...`);

            try {
                const res = await fetch(`${API_BASE}/api/documents/${docId}/review`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic: `„Éâ„Ç≠„É•„É°„É≥„Éà„Äå${filename}„Äç„ÅÆÁ¢∫Ë™ç`, user_id: USER_ID })
                });

                if (!res.ok) throw new Error('Failed to start document review session');

                const data = await res.json();
                sessionId = data.session_id;
                currentIntent = `„Éâ„Ç≠„É•„É°„É≥„Éà„Äå${filename}„Äç„ÅÆÁ¢∫Ë™ç`;

                // Remove from pending review queue
                _pendingReviewDocs = _pendingReviewDocs.filter(d => d.id !== docId);
                renderPendingReviewBanner();

                // Switch to chat screen
                startScreen.classList.add('hidden');
                chatScreen.classList.remove('hidden');
                chatMessages.innerHTML = '';

                // Show initial exchange in chat
                addMessage(currentIntent, 'user');
                addMessage(data.opening_message, 'assistant');
                messageInput.focus();
                updateStatus('Collecting');

                if (data.prior_knowledge_count > 0) {
                    showToast(`${data.prior_knowledge_count}‰ª∂„ÅÆÈÅéÂéª„ÅÆË®òÈå≤„Å®ÁÖßÂêà„Åó„Åæ„Åó„Åü`, 'info');
                    if (knowledgeMap) knowledgeMap.onFactVerified(data.prior_knowledge_count);
                }

            } catch (err) {
                console.error('Error starting document review:', err);
                showToast(`‚ùå „Éâ„Ç≠„É•„É°„É≥„Éà„É¨„Éì„É•„Éº„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`, 'error');
            } finally {
                isStarting = false;
                hideSessionLoading();
            }
        }
        // Expose for onclick in rendered HTML
        window.startDocumentReview = startDocumentReview;

        // In-chat notification shown after AI response when pending reviews exist
        function showDocumentReviewNoticeInChat() {
            if (_pendingReviewDocs.length === 0 || _reviewNotifiedInChat) return;
            _reviewNotifiedInChat = true;

            const docs = _pendingReviewDocs;
            const docList = docs.map(d => {
                const factsInfo = d.extracted_facts_count ? `${d.extracted_facts_count}‰ª∂„ÅÆ‰∫ãÂÆü„ÇíÊäΩÂá∫` : 'ÂàÜÊûêÂÆå‰∫Ü';
                return `<div class="flex items-center justify-between gap-2 py-1">
                    <span class="text-xs text-slate-300 truncate">üìÑ ${escapeHtml(d.filename)}<span class="text-slate-500 ml-1">Ôºà${factsInfo}Ôºâ</span></span>
                    <button onclick="startDocumentReview('${d.id}', '${escapeHtml(d.filename)}')" data-session-btn
                        class="shrink-0 text-[10px] text-accent hover:text-accent-bright underline underline-offset-2">„É¨„Éì„É•„ÉºÈñãÂßã</button>
                </div>`;
            }).join('');

            const div = document.createElement('div');
            div.className = 'fade-up flex justify-center my-2';
            div.innerHTML = `
                <div class="bg-surface-2/80 border border-white/5 rounded-xl px-4 py-3 max-w-[85%] backdrop-blur-sm">
                    <p class="text-[11px] text-slate-400 mb-1.5">üìã ÂàÜÊûê„ÅåÂÆå‰∫Ü„Åó„Åü„Éâ„Ç≠„É•„É°„É≥„Éà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰ºöË©±„ÅåÁµÇ„Çè„Å£„Åü„Çâ„É¨„Éì„É•„Éº„Åß„Åç„Åæ„Åô„ÄÇ</p>
                    <div class="divide-y divide-white/5">${docList}</div>
                </div>
            `;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Start screen banner for pending reviews
        function renderPendingReviewBanner() {
            const banner = document.getElementById('pending-review-banner');
            if (!banner) return;

            if (_pendingReviewDocs.length === 0) {
                banner.classList.add('hidden');
                return;
            }

            banner.classList.remove('hidden');
            const listEl = document.getElementById('pending-review-list');
            if (!listEl) return;

            listEl.innerHTML = _pendingReviewDocs.map(d => {
                const factsInfo = d.extracted_facts_count ? `${d.extracted_facts_count}‰ª∂„ÅÆ‰∫ãÂÆü` : '';
                return `
                    <button onclick="startDocumentReview('${d.id}', '${escapeHtml(d.filename)}')" data-session-btn
                        class="w-full flex items-center gap-2 p-2 rounded-lg bg-surface-2 hover:bg-surface-3 border border-white/5 hover:border-accent/30 transition-all text-left group">
                        <span class="text-base">üìÑ</span>
                        <div class="flex-1 min-w-0">
                            <p class="text-xs text-white truncate group-hover:text-accent transition-colors">${escapeHtml(d.filename)}</p>
                            ${factsInfo ? `<p class="text-[10px] text-slate-500">${factsInfo}„ÇíÊäΩÂá∫Ê∏à„Åø</p>` : ''}
                        </div>
                        <span class="text-[10px] text-accent opacity-0 group-hover:opacity-100 transition-opacity shrink-0">„É¨„Éì„É•„ÉºÈñãÂßã ‚Üí</span>
                    </button>
                `;
            }).join('');
        }

        function resetSession() {
            sessionId = null;
            currentIntent = '';
            facts = [];
            conflicts = [];
            pendingQuestions = [];
            
            chatMessages.innerHTML = '';
            intentInput.value = '';
            messageInput.value = '';
            conflictsSection.classList.add('hidden');
            questionsSection.classList.add('hidden');
            
            startScreen.classList.remove('hidden');
            chatScreen.classList.add('hidden');
            
            // Reset button states
            isStarting = false;
            if (startBtn) {
                startBtn.disabled = false;
                startBtnText.textContent = 'ÈñãÂßã';
                startBtnSpinner.classList.add('hidden');
            }
            if (newSessionBtn) {
                newSessionBtn.disabled = false;
                newSessionBtnText.textContent = '+ Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥';
                newSessionBtnSpinner.classList.add('hidden');
            }
            
            updateStatus('ÂæÖÊ©ü‰∏≠');
            _reviewNotifiedInChat = false; // Reset for next session
            loadSessions();
            // Reload all facts from knowledge graph (keeps document-derived facts visible)
            loadAllFacts();
            // Show pending review banner on start screen
            renderPendingReviewBanner();
        }

        function escapeHtml(str) {
            return String(str || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // =====================================================
        // Document Upload & Knowledge Summary
        // =====================================================
        
        // Document upload area
        const uploadDropzone = document.getElementById('upload-dropzone-main');
        const fileInput = document.getElementById('file-input-main');
        const documentsList = document.getElementById('documents-list-main');
        const documentsCountBadge = document.getElementById('documents-count-badge-top');
        
        const summaryToggle = document.getElementById('summary-toggle');
        const summaryPanel = document.getElementById('summary-panel');
        const generateSummaryBtn = document.getElementById('generate-summary-btn');
        
        let uploadedDocuments = [];
        let knowledgeStats = { total_facts: 0, total_documents: 0, total_sessions: 0, topics: [], entities: [] };

        // Toggle summary panel
        const summaryArrow = document.getElementById('summary-arrow');
        summaryToggle?.addEventListener('click', () => {
            const isHidden = summaryPanel.classList.toggle('hidden');
            if (summaryArrow) summaryArrow.textContent = isHidden ? '‚ñ∂' : '‚ñº';
            if (!isHidden) {
                loadKnowledgeStats();
            }
        });

        // File input change
        fileInput?.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                uploadFiles(e.target.files);
            }
        });

        // Click on dropzone
        uploadDropzone?.addEventListener('click', () => {
            fileInput?.click();
        });

        // Drag and drop
        uploadDropzone?.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadDropzone.classList.add('border-blue-400', 'bg-blue-400/10');
        });

        uploadDropzone?.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadDropzone.classList.remove('border-blue-400', 'bg-blue-400/10');
        });

        uploadDropzone?.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadDropzone.classList.remove('border-blue-400', 'bg-blue-400/10');
            if (e.dataTransfer.files.length > 0) {
                uploadFiles(e.dataTransfer.files);
            }
        });

        async function uploadFiles(files) {
            for (const file of files) {
                await uploadSingleFile(file);
            }
        }

        async function uploadSingleFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            // Show uploading status
            showToast(`üì§ ${file.name} „Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...`, 'info');

            try {
                const response = await fetch(`${API_BASE}/api/documents/upload`, {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error(`Upload failed: ${response.status}`);
                }

                const doc = await response.json();
                showToast(`üìÑ ${file.name} „Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü„ÄÇLLM„ÅßÂàÜÊûê„ÇíÈñãÂßã„Åó„Åæ„Åô...`, 'success');
                
                // Reload documents list (will auto-refresh while processing)
                loadDocuments();
            } catch (error) {
                console.error('Upload error:', error);
                showToast(`‚ùå ${file.name} „ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`, 'error');
            }
        }

        let _prevDocStatuses = {};
        let _pendingReviewDocs = []; // Docs that completed analysis but haven't been reviewed yet
        let _reviewNotifiedInChat = false; // Whether in-chat notification has been shown
        let _initialDocLoadDone = false;
        async function loadDocuments() {
            try {
                const response = await fetch(`${API_BASE}/api/documents`);
                if (!response.ok) return;
                
                const data = await response.json();
                const prevDocs = uploadedDocuments;
                uploadedDocuments = data.documents || [];
                
                // Detect newly completed documents and refresh knowledge map
                let newlyCompleted = false;
                uploadedDocuments.forEach(d => {
                    if (d.status === 'completed' && _prevDocStatuses[d.id] && _prevDocStatuses[d.id] !== 'completed') {
                        newlyCompleted = true;
                        // Add to pending review queue if not already there
                        if (!_pendingReviewDocs.some(p => p.id === d.id)) {
                            _pendingReviewDocs.push(d);
                            _reviewNotifiedInChat = false; // Reset so next AI response mentions it
                            // Show subtle toast notification
                            showToast(`üìÑ „Äå${d.filename}„Äç„ÅÆÂàÜÊûê„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`, 'info');
                        }
                    }
                });
                
                // On initial page load: restore pending review docs from API data
                // Documents that are completed and have an active (non-ended) review session
                // should be shown in the pending review banner
                if (!_initialDocLoadDone) {
                    _initialDocLoadDone = true;
                    uploadedDocuments.forEach(d => {
                        if (d.status === 'completed' && d.review_session_id) {
                            // Has an active review session ‚Äî add to pending review queue
                            if (!_pendingReviewDocs.some(p => p.id === d.id)) {
                                _pendingReviewDocs.push(d);
                            }
                        }
                    });
                }
                
                // Save current statuses
                _prevDocStatuses = {};
                uploadedDocuments.forEach(d => _prevDocStatuses[d.id] = d.status);
                
                if (newlyCompleted && knowledgeMap) {
                    knowledgeMap.loadTagData();
                }
                
                // Update start screen banner if visible
                renderPendingReviewBanner();
                
                // Update badge
                if (documentsCountBadge) documentsCountBadge.textContent = `${uploadedDocuments.length} files`;
                
                renderDocuments();
            } catch (error) {
                console.error('Failed to load documents:', error);
            }
        }

        function renderDocuments() {
            const emptyMessage = '<p class="text-[10px] text-slate-600 text-center py-2">„Éâ„Ç≠„É•„É°„É≥„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
            
            if (uploadedDocuments.length === 0) {
                if (documentsList) documentsList.innerHTML = emptyMessage;
                return;
            }

            const docHtml = uploadedDocuments.map(doc => {
                const statusConfig = {
                    'completed': { icon: '‚úÖ', color: 'text-verified', label: 'ÂÆå‰∫Ü' },
                    'processing': { icon: '‚è≥', color: 'text-amber-400', label: 'ÂàÜÊûê‰∏≠...' },
                    'uploading': { icon: 'üì§', color: 'text-blue-400', label: '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠' },
                    'failed': { icon: '‚ùå', color: 'text-conflict', label: '„Ç®„É©„Éº' },
                };
                const status = statusConfig[doc.status] || statusConfig['uploading'];
                
                // Build detail section for completed documents
                let detailHtml = '';
                if (doc.status === 'completed') {
                    const parts = [];
                    if (doc.extracted_facts_count > 0) {
                        parts.push(`<span class="text-verified">${doc.extracted_facts_count} facts</span>`);
                    }
                    if (doc.topics?.length > 0) {
                        parts.push(`<span class="text-blue-400">${doc.topics.slice(0, 2).join(', ')}</span>`);
                    }
                    if (doc.domain && doc.domain !== 'general') {
                        parts.push(`<span class="text-purple-400">${doc.domain}</span>`);
                    }
                    detailHtml = parts.length > 0 
                        ? `<p class="text-[10px] text-slate-500 mt-0.5">${parts.join(' ¬∑ ')}</p>` 
                        : '';
                    
                    // Show summary preview if available
                    if (doc.extracted_summary) {
                        const summaryPreview = doc.extracted_summary.length > 60 
                            ? doc.extracted_summary.substring(0, 60) + '...' 
                            : doc.extracted_summary;
                        detailHtml += `<p class="text-[9px] text-slate-600 mt-1 italic">"${escapeHtml(summaryPreview)}"</p>`;
                    }
                } else if (doc.status === 'processing') {
                    detailHtml = `<p class="text-[10px] text-amber-400/70 mt-0.5 animate-pulse">LLM„ÅßÂÜÖÂÆπ„ÇíÂàÜÊûê„Åó„Å¶„ÅÑ„Åæ„Åô...</p>`;
                } else if (doc.status === 'failed') {
                    const errorMsg = doc.error_message || 'Âá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
                    detailHtml = `<p class="text-[10px] text-conflict/70 mt-0.5">${escapeHtml(errorMsg.substring(0, 50))}</p>`;
                }
                
                // Pending review badge for completed documents
                const isPendingReview = _pendingReviewDocs.some(p => p.id === doc.id);
                const reviewBadgeHtml = (doc.status === 'completed' && isPendingReview) ? `
                    <button onclick="startDocumentReview('${doc.id}', '${escapeHtml(doc.filename)}')" data-session-btn
                        class="mt-1.5 w-full flex items-center justify-center gap-1.5 py-1.5 px-2 rounded-lg bg-accent/10 border border-accent/20 hover:bg-accent/20 hover:border-accent/40 transition-all group">
                        <span class="text-[10px]">üîç</span>
                        <span class="text-[10px] text-accent font-medium group-hover:text-accent-bright">„É¨„Éì„É•„ÉºÂæÖ„Å° ‚Äî „ÇØ„É™„ÉÉ„ÇØ„ÅßÈñãÂßã</span>
                    </button>` : '';

                // Tags for this document (will be loaded asynchronously)
                const tagPlaceholder = doc.status === 'completed' ? `
                    ${reviewBadgeHtml}
                    <div class="doc-tags flex flex-wrap gap-1 mt-1.5" data-doc-id="${doc.id}"></div>
                    <div class="flex gap-2 mt-2 pt-2 border-t border-white/5">
                        <button id="tag-btn-${doc.id}" onclick="refreshDocumentTags('${doc.id}')" class="flex-1 text-[10px] text-slate-400 hover:text-emerald-400 hover:bg-emerald-400/10 py-1 px-2 rounded transition-colors">
                            üè∑Ô∏è „Çø„Ç∞ÂÜçÁîüÊàê
                        </button>
                        <button id="extract-btn-${doc.id}" onclick="extractDocumentFacts('${doc.id}')" class="flex-1 text-[10px] text-slate-400 hover:text-purple-400 hover:bg-purple-400/10 py-1 px-2 rounded transition-colors">
                            üìä FactsÊäΩÂá∫
                        </button>
                    </div>` : '';
                
                return `
                    <div class="p-2 bg-surface-2 rounded text-xs border border-white/5 hover:border-white/10 transition-colors">
                        <div class="flex items-start gap-2">
                            <span class="${status.color} text-sm">${status.icon}</span>
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center justify-between gap-1">
                                    <p class="text-white truncate font-medium">${escapeHtml(doc.filename)}</p>
                                    <span class="text-[9px] ${status.color} whitespace-nowrap">${status.label}</span>
                                </div>
                                ${detailHtml}
                                ${tagPlaceholder}
                            </div>
                            <button onclick="deleteDocument('${doc.id}')" class="text-slate-500 hover:text-conflict text-xs ml-1 opacity-50 hover:opacity-100">√ó</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            if (documentsList) documentsList.innerHTML = docHtml;
            
            // Load tags for completed documents
            loadDocumentTags();
            
            // Auto-refresh if any documents are still processing
            const hasProcessing = uploadedDocuments.some(d => d.status === 'processing' || d.status === 'uploading');
            if (hasProcessing) {
                setTimeout(() => loadDocuments(), 3000); // Refresh every 3 seconds
            }
        }
        
        async function loadDocumentTags() {
            const tagContainers = document.querySelectorAll('.doc-tags[data-doc-id]');
            for (const container of tagContainers) {
                const docId = container.dataset.docId;
                try {
                    const res = await fetch(`${API_BASE}/api/documents/${docId}/tags`);
                    if (res.ok) {
                        const tags = await res.json();
                        if (tags.length > 0) {
                            container.innerHTML = tags.slice(0, 3).map(t => {
                                const bgColor = t.tag.color || getTagColor(t.tag.name);
                                return `<span class="inline-block px-1.5 py-0.5 text-[9px] rounded" style="background: ${bgColor}20; color: ${bgColor};">${escapeHtml(t.tag.name)}</span>`;
                            }).join('') + (tags.length > 3 ? `<span class="text-[9px] text-slate-500 ml-1">+${tags.length - 3}</span>` : '');
                        } else {
                            container.innerHTML = '<span class="text-[9px] text-slate-600">„Çø„Ç∞„Å™„Åó</span>';
                        }
                    }
                } catch (e) {
                    console.error('Error loading doc tags:', e);
                }
            }
        }
        
        // Refresh document tags using LLM
        const _taggingDocs = new Set();
        window.refreshDocumentTags = async function(docId) {
            if (_taggingDocs.has(docId)) {
                showToast('üè∑Ô∏è „Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅØ„Çø„Ç∞ÁîüÊàê‰∏≠„Åß„Åô„ÄÇÂÆå‰∫Ü„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ', 'info');
                return;
            }
            _taggingDocs.add(docId);

            const btn = document.getElementById(`tag-btn-${docId}`);
            const originalText = btn?.innerHTML;
            if (btn) {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed', 'pointer-events-none');
                btn.innerHTML = '<span class="inline-flex items-center gap-1"><span class="animate-spin text-[10px]">‚è≥</span> ÁîüÊàê‰∏≠...</span>';
            }

            const container = document.querySelector(`.doc-tags[data-doc-id="${docId}"]`);
            if (container) {
                container.innerHTML = '<span class="text-[9px] text-amber-400 animate-pulse">üè∑Ô∏è „Çø„Ç∞ÁîüÊàê‰∏≠...</span>';
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/documents/${docId}/tags/refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (res.ok) {
                    const result = await res.json();
                    showToast(`üè∑Ô∏è ${result.tags_assigned}ÂÄã„ÅÆ„Çø„Ç∞„Çí‰ªò‰∏é„Åó„Åæ„Åó„Åü`, 'success');
                    loadDocumentTags();
                    loadTags();
                    if (knowledgeMap) knowledgeMap.loadTagData();
                } else {
                    const error = await res.json();
                    showToast(`‚ùå ${error.detail || '„Çø„Ç∞ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'}`, 'error');
                    if (container) container.innerHTML = '<span class="text-[9px] text-slate-600">„Çø„Ç∞„Å™„Åó</span>';
                }
            } catch (e) {
                console.error('Error refreshing tags:', e);
                showToast('‚ùå „Çø„Ç∞ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                if (container) container.innerHTML = '<span class="text-[9px] text-slate-600">„Çø„Ç∞„Å™„Åó</span>';
            } finally {
                _taggingDocs.delete(docId);
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed', 'pointer-events-none');
                    btn.innerHTML = originalText || 'üè∑Ô∏è „Çø„Ç∞ÂÜçÁîüÊàê';
                }
            }
        };

        // Extract (or re-extract) facts from a document using LLM
        const _extractingDocs = new Set();
        window.extractDocumentFacts = async function(docId) {
            // Prevent double-click
            if (_extractingDocs.has(docId)) {
                showToast('üìä „Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅØÁèæÂú®ÂàÜÊûê‰∏≠„Åß„Åô„ÄÇÂÆå‰∫Ü„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ', 'info');
                return;
            }
            _extractingDocs.add(docId);

            const btn = document.getElementById(`extract-btn-${docId}`);
            const originalText = btn?.innerHTML;
            if (btn) {
                btn.disabled = true;
                btn.classList.add('opacity-50', 'cursor-not-allowed', 'pointer-events-none');
                btn.innerHTML = '<span class="inline-flex items-center gap-1"><span class="animate-spin text-[10px]">‚è≥</span> ÂàÜÊûê‰∏≠...</span>';
            }

            showToast('üìä „Éâ„Ç≠„É•„É°„É≥„Éà„Åã„ÇâFacts„ÇíÊäΩÂá∫‰∏≠... LLM„ÅßÂàÜÊûê„Åô„Çã„Åü„ÇÅ1„Äú2ÂàÜ„Åã„Åã„Çä„Åæ„Åô', 'info');
            
            try {
                const res = await fetch(`${API_BASE}/api/documents/${docId}/facts/extract`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (res.ok) {
                    const result = await res.json();
                    if (result.facts_extracted === 0) {
                        showToast('üìä Facts„ÇíÊäΩÂá∫„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 'info');
                    } else {
                        const msg = result.previous_facts_deleted > 0 
                            ? `üìä ${result.facts_extracted}‰ª∂„ÅÆFacts„ÇíÂÜçÊäΩÂá∫„Åó„Åæ„Åó„ÅüÔºà${result.facts_tagged}ÂÄã„ÅÆ„Çø„Ç∞‰ªò‰∏éÔºâ`
                            : `üìä ${result.facts_extracted}‰ª∂„ÅÆFacts„ÇíÊäΩÂá∫„Åó„Åæ„Åó„ÅüÔºà${result.facts_tagged}ÂÄã„ÅÆ„Çø„Ç∞‰ªò‰∏éÔºâ`;
                        showToast(msg, 'success');
                        loadTags();
                        loadAllFacts();
                        loadDocuments();
                        loadKnowledgeStats();
                        if (knowledgeMap) knowledgeMap.loadTagData();
                    }
                    
                    if (result.errors?.length > 0) {
                        console.warn('Extraction had errors:', result.errors);
                    }
                } else {
                    const error = await res.json();
                    showToast(`‚ùå ${error.detail || 'FactsÊäΩÂá∫„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'}`, 'error');
                }
            } catch (e) {
                console.error('Error extracting facts:', e);
                showToast('‚ùå FactsÊäΩÂá∫„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            } finally {
                _extractingDocs.delete(docId);
                if (btn) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed', 'pointer-events-none');
                    btn.innerHTML = originalText || 'üìä FactsÊäΩÂá∫';
                }
            }
        };

        window.deleteDocument = async function(docId) {
            if (!confirm('„Åì„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/documents/${docId}`, {
                    method: 'DELETE',
                });
                
                if (response.ok) {
                    showToast('üóëÔ∏è „Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü', 'info');
                    loadDocuments();
                }
            } catch (error) {
                console.error('Failed to delete document:', error);
                showToast('‚ùå ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };

        async function loadKnowledgeStats() {
            try {
                const response = await fetch(`${API_BASE}/api/knowledge/stats`);
                if (!response.ok) return;
                
                knowledgeStats = await response.json();
                renderKnowledgeStats();
            } catch (error) {
                console.error('Failed to load knowledge stats:', error);
            }
        }

        function renderKnowledgeStats() {
            document.getElementById('stat-facts').textContent = knowledgeStats.total_facts || 0;
            document.getElementById('stat-docs').textContent = knowledgeStats.total_documents || 0;
            document.getElementById('stat-sessions').textContent = knowledgeStats.total_sessions || 0;

            const topicsList = document.getElementById('topics-list');
            if (knowledgeStats.topics?.length > 0) {
                topicsList.innerHTML = knowledgeStats.topics.slice(0, 5).map(t => `
                    <button 
                        onclick="showTopicSummary('${escapeHtml(t.name)}')"
                        class="px-2 py-0.5 bg-purple-500/20 text-purple-400 text-[10px] rounded hover:bg-purple-500/30"
                    >
                        ${escapeHtml(t.name)} (${t.fact_count})
                    </button>
                `).join('');
            } else {
                topicsList.innerHTML = '<span class="text-xs text-slate-600">-</span>';
            }
        }

        generateSummaryBtn?.addEventListener('click', async () => {
            // Show entity selection modal
            if (knowledgeStats.entities?.length > 0) {
                showEntitySelectionModal();
            } else if (knowledgeStats.topics?.length > 0) {
                showTopicSummary(knowledgeStats.topics[0].name);
            } else {
                showToast('„Åæ„Å†Ë¶ÅÁ¥Ñ„Åô„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'info');
            }
        });

        function showEntitySelectionModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            
            const entities = [...(knowledgeStats.topics || []), ...(knowledgeStats.entities || [])];
            
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-md w-full border border-white/5 max-h-[80vh] overflow-y-auto">
                    <h2 class="text-lg font-semibold text-white mb-4">üìä „Çµ„Éû„É™„ÉºÁîüÊàê</h2>
                    <p class="text-sm text-slate-400 mb-4">Ë¶ÅÁ¥Ñ„Åô„Çã„Éà„Éî„ÉÉ„ÇØ„Åæ„Åü„ÅØ„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„ÇíÈÅ∏Êäû</p>
                    <div class="space-y-2 mb-4">
                        ${entities.map(e => `
                            <button 
                                onclick="showTopicSummary('${escapeHtml(e.name)}'); this.closest('.fixed').remove();"
                                class="w-full text-left px-4 py-2 bg-surface-3 hover:bg-surface-4 rounded-lg text-sm text-white flex justify-between items-center"
                            >
                                <span>${escapeHtml(e.name)}</span>
                                <span class="text-xs text-slate-500">${e.fact_count} facts</span>
                            </button>
                        `).join('')}
                    </div>
                    <button class="w-full py-2 bg-surface-3 text-slate-300 rounded-lg text-sm" onclick="this.closest('.fixed').remove()">„Ç≠„É£„É≥„Çª„É´</button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
        }

        window.showTopicSummary = async function(topic) {
            showToast(`üìä ${topic} „ÅÆË¶ÅÁ¥Ñ„ÇíÁîüÊàê‰∏≠...`, 'info');
            
            try {
                // Try entity first, then topic
                let response = await fetch(`${API_BASE}/api/knowledge/entities/${encodeURIComponent(topic)}/summarize`, {
                    method: 'POST',
                });
                
                if (!response.ok) {
                    response = await fetch(`${API_BASE}/api/knowledge/topics/${encodeURIComponent(topic)}/summarize`, {
                        method: 'POST',
                    });
                }
                
                if (!response.ok) {
                    throw new Error('Failed to generate summary');
                }
                
                const summary = await response.json();
                showKnowledgeSummaryModal(summary);
            } catch (error) {
                console.error('Failed to generate summary:', error);
                showToast('‚ùå „Çµ„Éû„É™„ÉºÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
            }
        };

        function showAggregationSuggestion(suggestion) {
            const existingSuggestion = document.getElementById('aggregation-toast');
            if (existingSuggestion) existingSuggestion.remove();
            
            const toast = document.createElement('div');
            toast.id = 'aggregation-toast';
            toast.className = 'fixed bottom-24 right-4 bg-purple-600 text-white p-4 rounded-lg shadow-lg z-40 max-w-sm fade-up';
            toast.innerHTML = `
                <div class="flex items-start gap-3">
                    <span class="text-2xl">üìä</span>
                    <div class="flex-1">
                        <p class="text-sm font-medium mb-1">${escapeHtml(suggestion.message)}</p>
                        <div class="flex gap-2 mt-2">
                            <button onclick="showTopicSummary('${escapeHtml(suggestion.topic)}'); this.closest('#aggregation-toast').remove();" class="px-3 py-1 bg-white/20 hover:bg-white/30 rounded text-xs">„Çµ„Éû„É™„ÉºÁîüÊàê</button>
                            <button onclick="this.closest('#aggregation-toast').remove();" class="px-3 py-1 bg-white/10 hover:bg-white/20 rounded text-xs">Âæå„Åß</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(toast);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => toast.remove(), 10000);
        }

        function showKnowledgeSummaryModal(summary) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-lg w-full border border-white/5 max-h-[80vh] overflow-y-auto">
                    <h2 class="text-lg font-semibold text-white mb-2">üìä ${escapeHtml(summary.topic)}</h2>
                    <p class="text-[10px] text-slate-500 mb-4">${summary.fact_count} facts ¬∑ ${summary.time_range || ''}</p>
                    
                    <div class="bg-surface-3 rounded-lg p-4 mb-4">
                        <p class="text-sm text-slate-300">${escapeHtml(summary.summary)}</p>
                    </div>
                    
                    ${summary.key_points?.length > 0 ? `
                        <div class="mb-4">
                            <h3 class="text-xs text-slate-400 mb-2">ÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà</h3>
                            <ul class="text-sm text-slate-300 space-y-1">
                                ${summary.key_points.map(p => `<li class="flex items-start gap-2"><span class="text-purple-400">‚Ä¢</span>${escapeHtml(p)}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                    
                    ${summary.related_entities?.length > 0 ? `
                        <div class="mb-4">
                            <h3 class="text-xs text-slate-400 mb-2">Èñ¢ÈÄ£„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£</h3>
                            <div class="flex flex-wrap gap-1">
                                ${summary.related_entities.map(e => `<span class="px-2 py-0.5 bg-surface-4 text-xs text-slate-300 rounded">${escapeHtml(e)}</span>`).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    <button class="w-full py-2 bg-accent text-surface-0 rounded-lg font-medium" onclick="this.closest('.fixed').remove()">Èñâ„Åò„Çã</button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
        }

        // =====================================================
        // Tags Section Functions
        // =====================================================
        
        let tagsData = [];
        
        // Load all tags
        async function loadTags() {
            try {
                const res = await fetch(`${API_BASE}/api/tags`);
                if (!res.ok) return;
                tagsData = await res.json();
                renderTagCloud();
                document.getElementById('tags-count-badge').textContent = `${tagsData.length} tags`;
                updateMetrics();
            } catch (e) {
                console.error('Error loading tags:', e);
            }
        }
        
        function renderTagCloud() {
            const container = document.getElementById('tag-cloud');
            if (!tagsData || tagsData.length === 0) {
                container.innerHTML = '<span class="text-xs text-slate-600">„Çø„Ç∞„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</span>';
                return;
            }
            
            // Sort by usage count
            const sortedTags = [...tagsData].sort((a, b) => b.total_count - a.total_count);
            
            container.innerHTML = sortedTags.map(tag => {
                const bgColor = tag.color || getTagColor(tag.name);
                const isActive = tag.total_count > 0;
                const sizeClass = tag.total_count > 5 ? 'text-sm' : 'text-xs';
                
                return `
                    <button 
                        class="tag-chip px-2 py-1 ${sizeClass} rounded-full transition-all hover:scale-105 cursor-pointer flex items-center gap-1"
                        style="background: ${bgColor}20; color: ${bgColor}; border: 1px solid ${bgColor}${isActive ? '60' : '30'};"
                        data-tag-id="${tag.id}"
                        onclick="showTagDetail('${tag.id}')"
                        title="${tag.aliases?.length > 0 ? 'Aliases: ' + tag.aliases.join(', ') : ''}"
                    >
                        <span>${escapeHtml(tag.name)}</span>
                        ${tag.total_count > 0 ? `<span class="text-[10px] opacity-70">${tag.total_count}</span>` : ''}
                    </button>
                `;
            }).join('');
        }
        
        function getTagColor(name) {
            // Generate consistent color from name hash
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const hue = Math.abs(hash) % 360;
            return `hsl(${hue}, 70%, 55%)`;
        }
        
        // Show tag detail modal
        async function showTagDetail(tagId) {
            const tag = tagsData.find(t => t.id === tagId);
            if (!tag) return;
            
            // Fetch items for this tag
            let items = [];
            try {
                const res = await fetch(`${API_BASE}/api/tags/${tagId}/items`);
                if (res.ok) {
                    items = await res.json();
                }
            } catch (e) {
                console.error('Error fetching tag items:', e);
            }
            
            const bgColor = tag.color || getTagColor(tag.name);
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            modal.id = 'tag-detail-modal';
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-lg w-full border border-white/5 max-h-[80vh] overflow-y-auto">
                    <div class="flex items-start justify-between mb-4">
                        <div class="flex items-center gap-3">
                            <div class="w-4 h-4 rounded-full" style="background: ${bgColor}"></div>
                            <div>
                                <h2 class="text-lg font-semibold text-white">${escapeHtml(tag.name)}</h2>
                                ${tag.aliases?.length > 0 ? `<p class="text-[10px] text-slate-500">aliases: ${tag.aliases.join(', ')}</p>` : ''}
                            </div>
                        </div>
                        <button onclick="this.closest('#tag-detail-modal').remove()" class="text-slate-500 hover:text-white">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Stats -->
                    <div class="grid grid-cols-3 gap-2 mb-4">
                        <div class="bg-surface-3 rounded-lg p-2 text-center">
                            <div class="text-sm font-semibold text-white">${tag.insight_count || 0}</div>
                            <div class="text-[10px] text-slate-500">Facts</div>
                        </div>
                        <div class="bg-surface-3 rounded-lg p-2 text-center">
                            <div class="text-sm font-semibold text-white">${tag.document_count || 0}</div>
                            <div class="text-[10px] text-slate-500">Docs</div>
                        </div>
                        <div class="bg-surface-3 rounded-lg p-2 text-center">
                            <div class="text-sm font-semibold text-white">${(tag.avg_relevance * 100).toFixed(0) || 0}%</div>
                            <div class="text-[10px] text-slate-500">Relevance</div>
                        </div>
                    </div>
                    
                    <!-- Items List -->
                    <div class="mb-4">
                        <h3 class="text-xs text-slate-400 mb-2">Èñ¢ÈÄ£„Ç¢„Ç§„ÉÜ„É† (${items.length})</h3>
                        <div class="space-y-2 max-h-48 overflow-y-auto">
                            ${items.length > 0 ? items.map(item => `
                                <div class="bg-surface-3 rounded-lg p-2.5">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span class="text-[10px] px-1.5 py-0.5 rounded ${item.item_type === 'document' ? 'bg-blue-500/20 text-blue-400' : 'bg-purple-500/20 text-purple-400'}">${item.item_type === 'document' ? 'Doc' : 'Fact'}</span>
                                        <span class="text-xs text-white truncate flex-1">${escapeHtml(item.title || item.filename || 'Untitled')}</span>
                                        <span class="text-[10px] text-slate-500">${(item.relevance * 100).toFixed(0)}%</span>
                                    </div>
                                    ${item.summary ? `<p class="text-[11px] text-slate-400 line-clamp-2">${escapeHtml(item.summary.substring(0, 100))}${item.summary.length > 100 ? '...' : ''}</p>` : ''}
                                </div>
                            `).join('') : '<p class="text-xs text-slate-600 py-2 text-center">„Ç¢„Ç§„ÉÜ„É†„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>'}
                        </div>
                    </div>
                    
                    <!-- Actions -->
                    <div class="flex gap-2">
                        <button onclick="editTag('${tagId}')" class="flex-1 py-2 bg-surface-3 hover:bg-surface-4 text-slate-300 rounded-lg text-sm transition-colors">Á∑®ÈõÜ</button>
                        <button onclick="deleteTag('${tagId}')" class="flex-1 py-2 bg-red-500/20 hover:bg-red-500/30 text-red-400 rounded-lg text-sm transition-colors">ÂâäÈô§</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
        }
        
        // Create new tag modal
        function showCreateTagModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            modal.id = 'create-tag-modal';
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-sm w-full border border-white/5">
                    <h2 class="text-lg font-semibold text-white mb-4">Êñ∞Ë¶è„Çø„Ç∞‰ΩúÊàê</h2>
                    <form id="create-tag-form" class="space-y-4">
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">„Çø„Ç∞Âêç</label>
                            <input type="text" id="new-tag-name" required
                                class="w-full px-3 py-2 bg-surface-3 border border-white/10 rounded-lg text-white text-sm placeholder-slate-500"
                                placeholder="‰æã: „Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">„Ç´„É©„Éº</label>
                            <div class="flex gap-2 flex-wrap">
                                ${['#3b82f6', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'].map((c, i) => `
                                    <label class="cursor-pointer">
                                        <input type="radio" name="tag-color" value="${c}" class="hidden peer" ${i === 0 ? 'checked' : ''}>
                                        <div class="w-7 h-7 rounded-full peer-checked:ring-2 peer-checked:ring-white peer-checked:ring-offset-2 peer-checked:ring-offset-surface-2" style="background: ${c}"></div>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">Ë™¨Êòé (‰ªªÊÑè)</label>
                            <input type="text" id="new-tag-description"
                                class="w-full px-3 py-2 bg-surface-3 border border-white/10 rounded-lg text-white text-sm placeholder-slate-500"
                                placeholder="„Çø„Ç∞„ÅÆË™¨Êòé">
                        </div>
                        <div class="flex gap-2 mt-4">
                            <button type="button" onclick="this.closest('#create-tag-modal').remove()" 
                                class="flex-1 py-2 bg-surface-3 text-slate-300 rounded-lg text-sm">„Ç≠„É£„É≥„Çª„É´</button>
                            <button type="submit" class="flex-1 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm">‰ΩúÊàê</button>
                        </div>
                    </form>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            document.getElementById('create-tag-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = document.getElementById('new-tag-name').value.trim();
                const color = document.querySelector('input[name="tag-color"]:checked')?.value;
                const description = document.getElementById('new-tag-description').value.trim();
                
                if (!name) return;
                
                try {
                    const res = await fetch(`${API_BASE}/api/tags`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, color, description })
                    });
                    
                    if (res.ok) {
                        showToast('„Çø„Ç∞„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü', 'success');
                        loadTags();
                        if (knowledgeMap) knowledgeMap.loadTagData();
                        modal.remove();
                    } else if (res.status === 409) {
                        showToast('ÂêåÂêç„ÅÆ„Çø„Ç∞„ÅåÊó¢„Å´Â≠òÂú®„Åó„Åæ„Åô', 'error');
                    } else {
                        showToast('„Çø„Ç∞„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                    }
                } catch (e) {
                    console.error('Error creating tag:', e);
                    showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
                }
            });
        }
        
        // Delete tag
        async function deleteTag(tagId) {
            if (!confirm('„Åì„ÅÆ„Çø„Ç∞„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºüÈñ¢ÈÄ£„Åô„ÇãÂÖ®„Å¶„ÅÆ„É™„É≥„ÇØ„ÇÇÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ')) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/tags/${tagId}`, { method: 'DELETE' });
                if (res.ok) {
                    showToast('„Çø„Ç∞„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü', 'success');
                    loadTags();
                    if (knowledgeMap) knowledgeMap.loadTagData();
                    document.getElementById('tag-detail-modal')?.remove();
                } else {
                    showToast('ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                }
            } catch (e) {
                console.error('Error deleting tag:', e);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Edit tag
        function editTag(tagId) {
            const tag = tagsData.find(t => t.id === tagId);
            if (!tag) return;
            
            document.getElementById('tag-detail-modal')?.remove();
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            modal.id = 'edit-tag-modal';
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-sm w-full border border-white/5">
                    <h2 class="text-lg font-semibold text-white mb-4">„Çø„Ç∞Á∑®ÈõÜ</h2>
                    <form id="edit-tag-form" class="space-y-4">
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">„Çø„Ç∞Âêç</label>
                            <input type="text" id="edit-tag-name" required value="${escapeHtml(tag.name)}"
                                class="w-full px-3 py-2 bg-surface-3 border border-white/10 rounded-lg text-white text-sm">
                        </div>
                        <div>
                            <label class="block text-xs text-slate-400 mb-1">„Ç´„É©„Éº</label>
                            <div class="flex gap-2 flex-wrap">
                                ${['#3b82f6', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'].map(c => `
                                    <label class="cursor-pointer">
                                        <input type="radio" name="edit-tag-color" value="${c}" class="hidden peer" ${tag.color === c ? 'checked' : ''}>
                                        <div class="w-7 h-7 rounded-full peer-checked:ring-2 peer-checked:ring-white peer-checked:ring-offset-2 peer-checked:ring-offset-surface-2" style="background: ${c}"></div>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        <div class="flex gap-2 mt-4">
                            <button type="button" onclick="this.closest('#edit-tag-modal').remove()" 
                                class="flex-1 py-2 bg-surface-3 text-slate-300 rounded-lg text-sm">„Ç≠„É£„É≥„Çª„É´</button>
                            <button type="submit" class="flex-1 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm">‰øùÂ≠ò</button>
                        </div>
                    </form>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            document.getElementById('edit-tag-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = document.getElementById('edit-tag-name').value.trim();
                const color = document.querySelector('input[name="edit-tag-color"]:checked')?.value;
                
                try {
                    const res = await fetch(`${API_BASE}/api/tags/${tagId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, color })
                    });
                    
                    if (res.ok) {
                        showToast('„Çø„Ç∞„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü', 'success');
                        loadTags();
                        if (knowledgeMap) knowledgeMap.loadTagData();
                        modal.remove();
                    } else {
                        showToast('Êõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                    }
                } catch (e) {
                    console.error('Error updating tag:', e);
                    showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
                }
            });
        }
        
        // Tag management modal (merge tags)
        function showTagManageModal() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4';
            modal.id = 'tag-manage-modal';
            modal.innerHTML = `
                <div class="bg-surface-2 rounded-xl p-6 max-w-md w-full border border-white/5 max-h-[80vh] overflow-y-auto">
                    <h2 class="text-lg font-semibold text-white mb-4">„Çø„Ç∞ÁÆ°ÁêÜ</h2>
                    
                    <!-- Merge Section -->
                    <div class="mb-6">
                        <h3 class="text-sm text-slate-400 mb-2">„Çø„Ç∞„ÅÆÁµ±Âêà</h3>
                        <p class="text-[11px] text-slate-500 mb-3">È°û‰ºº„Çø„Ç∞„Çí1„Å§„Å´Áµ±Âêà„Åó„Åæ„Åô„ÄÇÁµ±ÂêàÂÖÉ„ÅÆ„Çø„Ç∞„ÅØÂâäÈô§„Åï„Çå„ÄÅÂÖ®„Å¶„ÅÆÈñ¢ÈÄ£‰ªò„Åë„ÅåÁµ±ÂêàÂÖà„Å´ÁßªÂãï„Åó„Åæ„Åô„ÄÇ</p>
                        
                        <div class="space-y-3">
                            <div>
                                <label class="block text-xs text-slate-400 mb-1">Áµ±ÂêàÂÖÉÔºàÂâäÈô§„Åï„Çå„Çã„Çø„Ç∞Ôºâ</label>
                                <select id="merge-source-tags" multiple class="w-full px-3 py-2 bg-surface-3 border border-white/10 rounded-lg text-white text-sm h-24">
                                    ${tagsData.map(t => `<option value="${t.id}">${escapeHtml(t.name)} (${t.total_count})</option>`).join('')}
                                </select>
                                <p class="text-[10px] text-slate-600 mt-1">Ctrl/Cmd+„ÇØ„É™„ÉÉ„ÇØ„ÅßË§áÊï∞ÈÅ∏Êäû</p>
                            </div>
                            <div>
                                <label class="block text-xs text-slate-400 mb-1">Áµ±ÂêàÂÖàÔºàÊÆã„Çã„Çø„Ç∞Ôºâ</label>
                                <select id="merge-target-tag" class="w-full px-3 py-2 bg-surface-3 border border-white/10 rounded-lg text-white text-sm">
                                    <option value="">ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</option>
                                    ${tagsData.map(t => `<option value="${t.id}">${escapeHtml(t.name)}</option>`).join('')}
                                </select>
                            </div>
                            <label class="flex items-center gap-2 text-xs text-slate-400">
                                <input type="checkbox" id="merge-add-aliases" checked class="rounded bg-surface-3 border-white/10">
                                Áµ±ÂêàÂÖÉ„ÅÆ„Çø„Ç∞Âêç„Çí„Ç®„Ç§„É™„Ç¢„Çπ„Å®„Åó„Å¶ËøΩÂä†
                            </label>
                            <button onclick="mergeTags()" class="w-full py-2 bg-amber-600 hover:bg-amber-700 text-white rounded-lg text-sm transition-colors">Áµ±ÂêàÂÆüË°å</button>
                        </div>
                    </div>
                    
                    <!-- All Tags List -->
                    <div>
                        <h3 class="text-sm text-slate-400 mb-2">ÂÖ®„Çø„Ç∞‰∏ÄË¶ß</h3>
                        <div class="space-y-1 max-h-40 overflow-y-auto">
                            ${tagsData.map(t => {
                                const bgColor = t.color || getTagColor(t.name);
                                return `
                                    <div class="flex items-center justify-between p-2 bg-surface-3 rounded">
                                        <div class="flex items-center gap-2">
                                            <div class="w-3 h-3 rounded-full" style="background: ${bgColor}"></div>
                                            <span class="text-sm text-white">${escapeHtml(t.name)}</span>
                                            ${t.aliases?.length > 0 ? `<span class="text-[10px] text-slate-500">(+${t.aliases.length})</span>` : ''}
                                        </div>
                                        <span class="text-xs text-slate-500">${t.total_count} items</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    
                    <button onclick="this.closest('#tag-manage-modal').remove()" class="w-full py-2 mt-4 bg-surface-3 text-slate-300 rounded-lg text-sm">Èñâ„Åò„Çã</button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
        }
        
        async function mergeTags() {
            const sourceSelect = document.getElementById('merge-source-tags');
            const targetSelect = document.getElementById('merge-target-tag');
            const addAliases = document.getElementById('merge-add-aliases').checked;
            
            const sourceIds = Array.from(sourceSelect.selectedOptions).map(o => o.value);
            const targetId = targetSelect.value;
            
            if (sourceIds.length === 0) {
                showToast('Áµ±ÂêàÂÖÉ„ÅÆ„Çø„Ç∞„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }
            if (!targetId) {
                showToast('Áµ±ÂêàÂÖà„ÅÆ„Çø„Ç∞„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }
            if (sourceIds.includes(targetId)) {
                showToast('Áµ±ÂêàÂÖÉ„Å®Áµ±ÂêàÂÖà„Å´Âêå„Åò„Çø„Ç∞„ÅØÊåáÂÆö„Åß„Åç„Åæ„Åõ„Çì', 'error');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/tags/merge`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_tag_ids: sourceIds,
                        target_tag_id: targetId,
                        add_as_aliases: addAliases
                    })
                });
                
                if (res.ok) {
                    const result = await res.json();
                    showToast(`${result.merged_count}ÂÄã„ÅÆ„Çø„Ç∞„ÇíÁµ±Âêà„Åó„Åæ„Åó„Åü`, 'success');
                    loadTags();
                    if (knowledgeMap) knowledgeMap.loadTagData();
                    document.getElementById('tag-manage-modal').remove();
                } else {
                    showToast('Áµ±Âêà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                }
            } catch (e) {
                console.error('Error merging tags:', e);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', 'error');
            }
        }
        
        // Add tag button (now inside Knowledge Summary)
        document.getElementById('add-tag-btn')?.addEventListener('click', showCreateTagModal);
        
        // Manage tags button (now inside Knowledge Summary)
        document.getElementById('manage-tags-btn')?.addEventListener('click', showTagManageModal);

        // Initialize
        loadSessions();
        loadDocuments();
        loadKnowledgeStats();
        loadTags();
        loadConflicts();
        loadAllFacts();
    </script>
</body>
</html>
